<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  
  <title>设计模式 - Bryce&#39;s Log</title>
  <meta name="description" content="设计模式">
  <meta name="keywords" content="[]">
  <meta name="author" content="Bryce">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#e0e0e0">
  <meta name="msapplication-navbutton-color" content="#e0e0e0">
  <meta name="apple-mobile-web-app-status-bar-style" content="#e0e0e0">

  <link rel="icon" href="/img/b.ico">
  <link rel="stylesheet" href="/libs/twitter-bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/libs/jqueryui/jquery-ui.min.css">
  <link rel="stylesheet" href="/libs/jquery.tocify/stylesheets/jquery.tocify.min.css">
  <link rel="stylesheet" href="/css/main.css">

  <link rel="stylesheet" href="/css/iconfont.css">

  <script src="/libs/jquery/jquery.min.js"></script>
  <script src="/libs/jquery-cookie/jquery.cookie-1.4.1.min.js"></script>
  <script src="/libs/twitter-bootstrap/js/bootstrap.min.js"></script>
  <script src="/libs/jqueryui/jquery-ui.min.js"></script>
  <script src="/libs/jquery.tocify/javascripts/jquery.tocify.min.js"></script>
</head>
<body>


<div class="wrap">
  <nav class="page-navigation">
    <div class="nav-container">
        <div class="page-header-logo">
            <h1 class="prince-log">
                <a href="/" class="home-link">Bryce&#39;s Log</a>
            </h1>
        </div>
        <button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <ul class="collapse navbar-collapse main-nav-items">
            <li class="menu-item">
                <a href="/" target="_self">主页</a>
            </li>
            <li class="menu-item">
                <a href="/categories/%e6%8a%80%e6%9c%af/" target="_self">技术</a>
            </li>
            <li class="menu-item">
                <a href="/categories/%e7%94%9f%e6%b4%bb/" target="_self">生活</a>
            </li>
            <li class="menu-item">
                <a href="/categories/%e9%9a%8f%e7%ac%94/" target="_self">随笔</a>
            </li>
            <li class="menu-item">
                <a href="/about/" target="_self">关于</a>
            </li><li class="menu-item">
                <div id="search-button">
                    <a class="site-page social-icon search" data-pjax-state="external">
                        <i class="iconfont icon-sousuo5"></i> 
                    </a>
                </div>
            </li>
            
        </ul>
    </div>
</nav>
  <main class="hiruko-container"><div class="post">
  <article class="post-block">
    <h1 class="post-title">设计模式</h1>
    <div class="post-info">Oct 1 2022</div>
    <div class="post-entry" id="blog-content">
      
      
      <p>写出可扩展、可读、可维护的高质量代码是对程序员的最高要求。本文介绍了软件开发中的经典设计原则和设计模式。</p>
<h2 id="前言"><strong>前言</strong></h2>
<h3 id="动机"><strong>动机</strong></h3>
<ul>
<li>
<p>应对面试中的设计模式相关问题</p>
</li>
<li>
<p>写出高质量代码，提高程序员基础素养，打牢基本功</p>
</li>
<li>
<p>提高复杂代码的设计和开发能力</p>
</li>
<li>
<p>深入理解框架、开源项目、中间件的源码和精髓</p>
</li>
<li>
<p>为职场发展做铺垫</p>
</li>
</ul>
<h3 id="标准"><strong>标准</strong></h3>
<ul>
<li>
<p>可维护性</p>
<ul>
<li>在<strong>不破坏原有代码设计</strong>下，能够<strong>快速</strong>地修改或者添加代码，同时<strong>不会引入新的bug</strong>。</li>
<li>一般来说，代码的可读性好、简洁、可扩展性好，代码的可维护性就越高；细化来说，代码分层清晰、模块化好、高内聚低耦合、面向接口而非实现编程，代码的可维护性就越高</li>
</ul>
</li>
<li>
<p>可读性</p>
<ul>
<li>代码易于阅读和理解。</li>
<li>代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合，影响着代码的可读性。</li>
</ul>
</li>
<li>
<p>可扩展性</p>
<ul>
<li>在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。</li>
<li>可扩展性好的代码预留了一些功能扩展点，使得新功能代码可直接插入扩展点，而不用修改原有代码。</li>
</ul>
</li>
<li>
<p>灵活性</p>
<ul>
<li>代码快速高效应对新变化的能力，即代码易扩展、易复用、易用的能力。</li>
<li>代码预留扩展点、代码抽象出底层可复用的模块/类、代码可应对各种使用场景/满足各种不同需求</li>
</ul>
</li>
<li>
<p>简洁性</p>
<ul>
<li>KISS：Keep It Simple Stupid，保持代码简单、逻辑清晰。</li>
</ul>
</li>
<li>
<p>可复用性</p>
<ul>
<li>DRY：Don&rsquo;t Repeat Yourself，尽量减少重复代码的编写，复用已有的代码。</li>
</ul>
</li>
<li>
<p>可测试性</p>
<ul>
<li>易于编写单元测试。</li>
</ul>
</li>
</ul>
<h3 id="理论"><strong>理论</strong></h3>
<h4 id="设计思想"><strong>设计思想</strong></h4>
<ul>
<li>面向对象
<ul>
<li>封装、抽象、继承、多态</li>
</ul>
</li>
</ul>
<h4 id="设计原则"><strong>设计原则</strong></h4>
<ul>
<li>
<p>SOLID原则：单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则</p>
</li>
<li>
<p>DRY原则：Don&rsquo;t Repeat Yourself</p>
</li>
<li>
<p>KISS原则：Keep It Simple，Stupid</p>
</li>
<li>
<p>YAGNI原则：You Ain&rsquo;t Gonna Need It</p>
</li>
<li>
<p>LOD原则：迪米特原则/最少知识原则</p>
</li>
</ul>
<h4 id="设计模式"><strong>设计模式</strong></h4>
<ul>
<li>
<p>创建型：单例模式、工厂模式、建造者模式、原型模式</p>
</li>
<li>
<p>结构型：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式</p>
</li>
<li>
<p>行为型：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式</p>
</li>
</ul>
<h4 id="编程规范"><strong>编程规范</strong></h4>
<ul>
<li>提高代码可读性</li>
</ul>
<h4 id="代码重构"><strong>代码重构</strong></h4>
<ul>
<li>
<p>重构的目的、对象、时机、方法</p>
</li>
<li>
<p>重构不出错的技术手段：单元测试、代码的可测试性</p>
</li>
<li>
<p>大重构、小重构</p>
</li>
</ul>
<h2 id="设计原则与思想"><strong>设计原则与思想</strong></h2>
<h3 id="面向对象"><strong>面向对象</strong></h3>
<h4 id="概念"><strong>概念</strong></h4>
<ul>
<li>
<p>面向对象编程：OOP，Object Oriented Programming，一种编程范式或风格，以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石。</p>
</li>
<li>
<p>面向对象编程语言：支持类或对象的语法机制，能方便的实现面向对象的四大特性的编程语言。</p>
</li>
<li>
<p>UML：Unified Model Language，统一建模语言</p>
</li>
</ul>
<h4 id="特性"><strong>特性</strong></h4>
<ul>
<li>
<p>封装（<strong>数据访问保护、操作权限收敛</strong>）</p>
<ul>
<li>概念：信息隐藏或者数据访问保护，类通过暴露有限的访问接口，使外部仅能通过类提供的方式来访问内部信息或数据</li>
<li>实现：编程语言提供访问控制语法，如private、protected、public等</li>
<li>意义：<strong>操作权限收敛</strong>，提高代码的可读性和可维护性；对外暴露有限接口、隐藏内部属性，提高类的易用性</li>
</ul>
</li>
<li>
<p>抽象（<strong>暴露接口、隐藏细节</strong>）</p>
<ul>
<li>概念：对外暴露操作接口、隐藏方法的具体实现</li>
<li>实现：如接口类、抽象类，广义上，函数也是抽象的实现</li>
<li>意义：使用者只需关注类提供的功能点，无需关注具体实现；提高代码的可扩展性和可维护性，修改实现不需要修改定义</li>
</ul>
</li>
<li>
<p>继承（<strong>代码复用</strong>）</p>
<ul>
<li>概念：子类通过继承父类，获取父类的属性和方法</li>
<li>实现：编程语言提供继承语法，如extends</li>
<li>意义：代码复用；反映类之间的关系</li>
</ul>
</li>
<li>
<p>多态（<strong>同一接口、不同行为</strong>）</p>
<ul>
<li>概念：同一个编程符号在运行时表现出不同行为的能力。</li>
<li>实现：
<ul>
<li>继承+方法重写
<ul>
<li>C++：编译器为含有虚函数的类生成一个虚函数表，同时该类生成的实例都会带有一个虚函数指针，子类进行方法重写后，虚函数表中对应的虚函数地址会覆写为子类重写后的函数地址；在运行时，调用虚函数时首先根据虚函数表指针定位到虚函数表，然后通过虚函数偏移定位到虚函数地址，从而实现动态绑定</li>
<li>Java：在运行时，根据符号引用到父类方法表中得到该方法在方法表中的偏移量（该偏移量仅在第一次解析时获取一次，然后将其存储/修改到字节码中），然后在当前实际调用该方法的实例中的方法表根据偏移量得到实际的地址，最后调用该地址，从而实现动态绑定</li>
</ul>
</li>
<li>接口类
<ul>
<li>Java：运行时，根据符号引用到当前实例的方法表中根据方法名称搜索得到实际的地址</li>
<li>Go：运行时，将非空接口转为iface类型，将空接口转为eface类型，iface中包含接口类型、实例类型、接口实际方法表，接口实际方法表在运行时生成，首先编译时接口和实际类型的方法都按照方法名排序，然后运行时，实例强转为iface时，同时遍历实例的方法表和接口的方法表，如果二者名称相同，则将该实例方法地址加到iface接口实际方法表中，总时间复杂度为O(m+n)</li>
</ul>
</li>
<li>duck-typing
<ul>
<li>动态语言：在运行时调用方法，不存在则报错</li>
<li>Golang虽然不用显式声明实现了某接口，但实际上在编译时也会进行是否实现方法的检查，因此Golang严格意义上不是duck-typing</li>
</ul>
</li>
</ul>
</li>
<li>意义：提高代码的可扩展性和可复用性</li>
</ul>
</li>
</ul>
<h4 id="对比面向过程"><strong>对比：面向过程</strong></h4>
<h5 id="概念-1"><strong>概念</strong></h5>
<ul>
<li>面向过程编程：以过程作为组织代码的基本单元，数据与方法分离，面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能</li>
</ul>
<h5 id="对比"><strong>对比</strong></h5>
<ul>
<li>
<p>OOP更加能够应对大规模复杂程序的开发</p>
<ul>
<li>OOP以类为思考对象，进行设计分析时，首先考虑如何对业务建模、如何将需求翻译为类、如何给类之间建立交互关系，之后再按照处理流程组装程序</li>
</ul>
</li>
<li>
<p>OOP风格的代码更易复用、易扩展、易维护</p>
<ul>
<li>OOP通过封装、抽象、继承、多态等特性，使代码更易复用、易扩展、易维护</li>
</ul>
</li>
<li>
<p>OOP更加贴近问题，更加远离底层机器</p>
</li>
</ul>
<h5 id="误用"><strong>误用</strong></h5>
<ul>
<li>
<p>滥用getter、setter方法</p>
<ul>
<li>实际上抛弃了OOP提供的封装特性，数据操作权限分散</li>
</ul>
</li>
<li>
<p>滥用全局变量和全局方法</p>
<ul>
<li>大而全的Constants常量类
<ul>
<li>将类拆解为功能更加单一的多个常量类</li>
<li>将业务类所需要的常量定义在类的内部</li>
</ul>
</li>
<li>实际上不能复用的Utils类
<ul>
<li>优先定义到业务类</li>
<li>将类拆解为功能单一的多个Utils类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>定义数据和方法分离的类</p>
<ul>
<li>基于贫血模型的开发模式：MVC架构
<ul>
<li>DTO、DO、PO只定义数据，不定义操作</li>
<li>操作定义在Controller、Service、Repository三层中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对于微小程序、数据处理相关程序、侧重算法而非数据的程序，面向过程的风格更为合适</p>
</li>
<li>
<p>灵活采用OOP和OPP，本质是写出易维护、易读、易复用、易扩展的高质量代码</p>
</li>
</ul>
<h4 id="抽象类vs接口"><strong>抽象类vs接口</strong></h4>
<h5 id="特性-1"><strong>特性</strong></h5>
<ul>
<li>
<p>抽象类</p>
<ul>
<li>不允许实例化，只能被继承</li>
<li>可以包含属性和方法，方法可以包含代码实现，也可以完全抽象</li>
<li>子类继承抽象类后，必须实现抽象类中的全部抽象方法</li>
</ul>
</li>
<li>
<p>接口</p>
<ul>
<li>不能包含属性/成员变量</li>
<li>只能声明方法，不能包含实现</li>
<li>类实现接口时，必须实现接口声明的全部方法</li>
</ul>
</li>
</ul>
<h5 id="意义"><strong>意义</strong></h5>
<ul>
<li>
<p>抽象类是对成员变量和方法的抽象，是一种is-a关系，解决代码复用问题，同时又强制子类实现抽象方法</p>
</li>
<li>
<p>接口是对方法的抽象，是一种has-a关系，解决解耦问题，隔离接口和具体的实现，提高代码的可扩展性</p>
</li>
<li>
<p>抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类</p>
</li>
<li>
<p>接口是一种自上而下的设计思路，先设计接口并面向接口编程，然后再具体实现接口</p>
</li>
</ul>
<h4 id="面向接口编程"><strong>面向接口编程</strong></h4>
<ul>
<li>
<p>含义：将接口和实现分离，封装不稳定的实现，暴露稳定的接口，上游系统面向接口而非实现编程，不依赖不稳定的实现细节，以此应对实现的变化，降低耦合性、提高扩展性</p>
</li>
<li>
<p>抉择：如果某个功能只有一种实现方式，未来也不可能被其他实现方式替换，则就没必要设计接口，直接使用实现类即可</p>
</li>
</ul>
<h4 id="组合vs继承"><strong>组合vs继承</strong></h4>
<h5 id="继承"><strong>继承</strong></h5>
<ul>
<li>
<p>表示is-a关系、支持多态特性、代码复用</p>
</li>
<li>
<p>继承层次过深、继承关系复杂时</p>
<ul>
<li>代码可读性变差，需要同时追溯多个类</li>
<li>破坏类的封装特性，将父类的实现细节暴露给子类（protected）</li>
<li>子类和父类高度耦合，父类的修改直接影响全部子类</li>
<li>子类需要获取多个父类能力时，需要创造m*n个父类</li>
</ul>
</li>
</ul>
<h5 id="组合"><strong>组合</strong></h5>
<ul>
<li>将父类提供的能力通过接口进行抽象，子类通过定义接口类型属性注入接口实现，并将方法委托给接口实现完成
<ul>
<li>组合+接口形成has-a关系，可替代is-a</li>
<li>接口可支持多态特性</li>
<li>组合+委托可实现代码复用</li>
<li>子类需要获取多个父类能力时，只需要创造m+n个类，然后进行组合</li>
</ul>
</li>
</ul>
<h5 id="权衡"><strong>权衡</strong></h5>
<ul>
<li>
<p>以代码复用为主要目的时，应考虑使用组合而非继承</p>
</li>
<li>
<p>通过模板模式设计类时，应使用继承</p>
</li>
<li>
<p>类之间的继承结构稳定、继承层次较浅、继承关系简单时，可采用继承</p>
</li>
<li>
<p>否则，应使用组合</p>
</li>
</ul>
<h4 id="贫血模型vs充血模型"><strong>贫血模型vs充血模型</strong></h4>
<h5 id="概念-2"><strong>概念</strong></h5>
<ul>
<li>
<p>贫血模型：数据和逻辑分离，例如在MVC架构中，业务逻辑在Service层，每层的对象DTO/DO/PO仅是数据的载体，本身不带有业务逻辑方法</p>
</li>
<li>
<p>充血模型：数据和数据对应的业务逻辑封装到同一个类中，例如在DDD的MVC架构中，Service层包含Service类和Domain类两部分，Domain类既包含数据，又包含业务逻辑</p>
</li>
<li>
<p>领域驱动设计：指导如何解耦业务系统，划分业务模块，定义业务领域模型及交互</p>
</li>
</ul>
<h5 id="权衡-1"><strong>权衡</strong></h5>
<ul>
<li>
<p>贫血模型适合业务逻辑简单的系统开发，如仅是基于SQL的CRUD操作</p>
</li>
<li>
<p>充血模型适合业务复杂的系统开发，如各种利息计算模型、还款模型等复杂业务的金融系统</p>
</li>
<li>
<p>不同开发模式导致不同的开发流程</p>
<ul>
<li>贫血模型：SQL驱动，根据业务需求到DB中查找相应的表，然后定义PO/DO/DTO，并编写SQL获取填充</li>
<li>充血模型：领域驱动，事先梳理好所有的业务，定义领域模型所包含的属性和方法，领域模型相当于可复用的业务中间层</li>
</ul>
</li>
<li>
<p>在充血模型的MVC开发中</p>
<ul>
<li>Domain类负责数据和业务逻辑</li>
<li>Service类负责与Repository交互，将PO转为Domain</li>
<li>Service类负责跨领域模型的业务聚合功能</li>
<li>Service类负责一些非功能性与三方系统交互的工作，如幂等、事务、消息、提醒、日志、调用RPC接口</li>
<li>Controller层的DTO和Repository层的PO不涉及复杂的业务逻辑，没必要设计成充血模型</li>
</ul>
</li>
</ul>
<h4 id="ooaood"><strong>OOA&amp;OOD</strong></h4>
<ul>
<li>
<p>OOA</p>
<ul>
<li>面向对象分析
<ul>
<li>需求分析清晰合理、不断迭代优化、做出合理取舍、权衡、假设</li>
</ul>
</li>
</ul>
</li>
<li>
<p>OOD</p>
<ul>
<li>面向对象设计
<ul>
<li>划分职责进而识别出有哪些类</li>
<li>定义类及属性和方法</li>
<li>定义类与类的交互关系：泛化、实现、组合、聚合、关联、依赖</li>
<li>将类组装起来并提供执行入口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设计原则-1"><strong>设计原则</strong></h3>
<h4 id="srp"><strong>SRP</strong></h4>
<h5 id="概念-3"><strong>概念</strong></h5>
<ul>
<li>
<p>SRP，Single Responsibility Principle，单一职责原则：一个类或者模块只负责完成一个职责(或者功能)</p>
</li>
<li>
<p>不要设计大而全的类，要设计粒度小、功能单一的类，以实现代码高内聚低耦合，提高代码的复用性、可读性、可维护性</p>
</li>
</ul>
<h5 id="判断"><strong>判断</strong></h5>
<ul>
<li>
<p>类中的代码行数、函数或者属性过多</p>
</li>
<li>
<p>类依赖的其他类过多</p>
</li>
<li>
<p>私有方法过多</p>
</li>
<li>
<p>比较难给类起一个合适的名字</p>
</li>
<li>
<p>类中大量的方法都是集中操作类中的某几个属性</p>
</li>
</ul>
<h5 id="权衡-2"><strong>权衡</strong></h5>
<ul>
<li>类拆分过细时，反而会降低内聚性，进而影响代码的可维护性</li>
</ul>
<h4 id="ocp"><strong>OCP</strong></h4>
<h5 id="概念-4"><strong>概念</strong></h5>
<ul>
<li>
<p>OCP，Open Closed Principle，开闭原则：软件实体(模块、类、方法)应该对扩展开放、对修改关闭</p>
</li>
<li>
<p>添加新功能时，应在已有代码的基础上扩展代码(新增模块、类、方法等)，而非修改已有代码</p>
</li>
<li>
<p>不是完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发</p>
</li>
</ul>
<h5 id="设计"><strong>设计</strong></h5>
<ul>
<li>
<p>扩展意识、抽象意识、封装意识</p>
<ul>
<li>识别出代码的可变部分和不可变部分</li>
<li>可变部分：需求迭代时变化的部分，事先留好扩展点</li>
</ul>
</li>
<li>
<p>具体设计</p>
<ul>
<li>多态</li>
<li>依赖注入</li>
<li>基于接口而非实现编程</li>
<li>绝大部分的设计模式（如装饰器、策略、模板、职责链等）</li>
</ul>
</li>
</ul>
<h4 id="lsp"><strong>LSP</strong></h4>
<h5 id="概念-5"><strong>概念</strong></h5>
<ul>
<li>
<p>LSP，Liskov Substitution Principle，里氏替换原则：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏</p>
</li>
<li>
<p>LSP还可以描述为：Design By Contract，按照协议来设计，即子类在设计的时候，要遵守父类的行为约定/协议：父类定义了函数的行为约定(包括函数声明要实现的功能；对输入、输出、异常的约定；父类注释中罗列的任何特殊说明)，子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定</p>
</li>
</ul>
<h5 id="使用"><strong>使用</strong></h5>
<ul>
<li>里氏替换原则用来指导继承关系中子类如何设计，核心是：Design By Contract，即子类不能违背父类的约束规则</li>
</ul>
<h4 id="isp"><strong>ISP</strong></h4>
<h5 id="概念-6"><strong>概念</strong></h5>
<ul>
<li>ISP，Interface Segregation Principle，接口隔离原则：客户端不应该被强迫依赖它不需要的接口</li>
</ul>
<h5 id="接口"><strong>接口</strong></h5>
<ul>
<li>
<p>一组API/RPC接口集合</p>
<ul>
<li>如果部分接口只被部分调用者使用，则需要把这部分接口隔离出来，单独给这部分调用者使用</li>
</ul>
</li>
<li>
<p>单个API接口或函数</p>
<ul>
<li>如果部分调用者只需要函数中的部分功能，则需要把函数拆分成粒度更细的多个函数</li>
</ul>
</li>
<li>
<p>OOP中的接口</p>
<ul>
<li>接口的设计尽量单一，不要让接口的实现类和调用者依赖不需要的接口函数</li>
</ul>
</li>
</ul>
<h4 id="dip"><strong>DIP</strong></h4>
<h5 id="概念-7"><strong>概念</strong></h5>
<ul>
<li>
<p>DIP，Dependency Inversion Principle，依赖反转原则：高层模块不要依赖底层模块，高层模块和底层模块应该通过抽象来相互依赖，抽象不要依赖具体实现细节，具体实现细节依赖抽象。</p>
</li>
<li>
<p>IOC，Inversion Of Control，控制反转：对程序执行流程的控制从程序员反转到框架</p>
</li>
<li>
<p>DI，Dependency Injection，依赖注入：不通过new的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递/注入给类使用</p>
</li>
<li>
<p>DI Framework，依赖注入框架：由框架自动创建对象、管理对象的生命周期、依赖注入等工作</p>
</li>
</ul>
<h4 id="kiss--yagni"><strong>KISS &amp; YAGNI</strong></h4>
<h5 id="核心"><strong>核心</strong></h5>
<ul>
<li>
<p>KISS，Keep It Simple and Stupid：保持简单</p>
<ul>
<li>简单：逻辑复杂度、实现难度、代码可读性</li>
<li>原则
<ul>
<li>不要使用过于复杂、高级的技术实现代码</li>
<li>不要重复造轮子</li>
<li>不要过度优化、不要过度使用一些奇技淫巧</li>
</ul>
</li>
</ul>
</li>
<li>
<p>YAGNI，You Ain&rsquo;t Gonna Need It：你不会需要它</p>
<ul>
<li>不要设计当前用不到的功能</li>
<li>不要编写当前用不到的代码</li>
<li>不要过度设计</li>
</ul>
</li>
</ul>
<h4 id="dry"><strong>DRY</strong></h4>
<h5 id="核心-1"><strong>核心</strong></h5>
<ul>
<li>
<p>DRY，Don&rsquo;t Repeat Yourself：不要重复</p>
</li>
<li>
<p>实现逻辑重复，不一定违反DRY</p>
</li>
<li>
<p>功能语义重复，违反DRY</p>
</li>
<li>
<p>代码执行重复，违反DRY</p>
</li>
</ul>
<h5 id="代码复用性"><strong>代码复用性</strong></h5>
<ul>
<li>
<p>概念：代码可被复用的能力</p>
</li>
<li>
<p>途径</p>
<ul>
<li>减少代码耦合</li>
<li>满足单一职责原则</li>
<li>模块化</li>
<li>业务与非业务逻辑分离</li>
<li>通用代码下沉</li>
<li>继承、多态、抽象、封装</li>
<li>应用模板等设计模式</li>
</ul>
</li>
<li>
<p>Rule of Three</p>
<ul>
<li>如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，则可不考虑代码的复用性，在之后开发新的功能的时候，如果需要复用，再进行重构以支持复用</li>
</ul>
</li>
</ul>
<h4 id="lod"><strong>LOD</strong></h4>
<h5 id="概念-8"><strong>概念</strong></h5>
<ul>
<li>
<p>高内聚、低耦合</p>
<ul>
<li>提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围</li>
<li>高内聚指导类本身的设计，低耦合指导类与类之间依赖关系的设计</li>
</ul>
</li>
<li>
<p>高内聚</p>
<ul>
<li>概念：相近的功能应该放到同一类，不相近的功能不要放到同一个类</li>
<li></li>
</ul>
</li>
<li>
<p>低耦合</p>
<ul>
<li>概念：代码中类与类之间的依赖关系简单清晰，即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类(依赖该类的类)的代码改动</li>
</ul>
</li>
<li>
<p>LOD</p>
<ul>
<li>Law Of Demeter：The Least Knowledge Principle：迪米特法则：最小知识原则</li>
<li>每个模块只应该了解那些和它关系密切的模块的有限知识，或者说，每个模块只和自己的朋友说话，不和陌生人说话。</li>
<li>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</li>
<li>基于最小接口而非最大实现编程</li>
</ul>
</li>
</ul>
<h4 id="案例实践"><strong>案例实践</strong></h4>
<h5 id="业务开发"><strong>业务开发</strong></h5>
<ul>
<li>追求长远发展的工程师，不能把自己只放在执行者的角色，不能只是一个代码实现者，还要有独立负责一个系统的能力，能端到端开发一个完整的系统：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护</li>
</ul>
<h5 id="案例积分系统"><strong>案例：积分系统</strong></h5>
<ul>
<li>
<p>需求分析</p>
<ul>
<li>借鉴竞品、借鉴其他平台/应用</li>
<li>线框图（UI图）</li>
<li>用户用例：侧重情景化，描述用户在一个特定的应用场景里的一个完整的业务操作流程</li>
<li>积分系统
<ul>
<li>积分赚取和兑换渠道：下订单、每日签到、评论</li>
<li>积分消费和兑换规则：抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分</li>
<li>积分及明细查询</li>
</ul>
</li>
</ul>
</li>
<li>
<p>系统设计</p>
<ul>
<li>合理的将功能划分到不同模块，实现模块层面的高内聚、低耦合，架构整洁清晰
<ul>
<li>一般来说，不希望下层系统包含太多上层系统的业务信息</li>
<li>如果一个功能的扩展、修改，需要涉及跨团队、跨项目、跨系统才能完成，则不符合低耦合的要求</li>
<li>积分系统
<ul>
<li>M1：积分赚取渠道、兑换规则、消费渠道、兑换规则的管理和维护由营销系统统一负责，积分系统仅负责积分的CRUD。订单系统等各业务系统-&gt;营销系统-&gt;积分系统</li>
<li>M2：积分赚取渠道、兑换规则、消费渠道、兑换规则的管理和维护由各业务系统各自负责和维护，积分系统仅负责积分的CRUD。订单系统等各业务系统-&gt;计算实际积分-&gt;积分系统</li>
<li>M：积分赚取渠道、兑换规则、消费渠道、兑换规则的管理和维护、积分的CRUD由积分系统统一负责。订单系统等各业务系统-&gt;积分系统</li>
</ul>
</li>
</ul>
</li>
<li>设计模块与模块之间的交互关系
<ul>
<li>交互方式：同步接口调用、异步消息通知</li>
</ul>
</li>
<li>设计模块的接口、数据库、业务模型
<ul>
<li>接口设计</li>
<li>数据库设计</li>
<li>业务模型设计</li>
</ul>
</li>
</ul>
</li>
<li>
<p>开发实现</p>
<ul>
<li>数据库设计</li>
<li>接口设计
<ul>
<li>接口粒度权衡
<ul>
<li>接口符合单一职责原则，粒度越小通用性越好</li>
<li>粒度过小时：一个功能要调用多个接口：性能问题、分布式数据一致性问题</li>
<li>兼顾易用性和性能：在职责单一的细粒度接口之上，封装一层粗粒度的接口给外部使用</li>
</ul>
</li>
</ul>
</li>
<li>业务模型设计</li>
</ul>
</li>
<li>
<p>MVC分层意义</p>
<ul>
<li>分层能起到代码复用的作用</li>
<li>分层起到隔离变化的作用</li>
<li>分层起到隔离关注点的作用</li>
<li>分层能提高代码的可测试性</li>
<li>分层能应对系统的复杂性</li>
</ul>
</li>
<li>
<p>DTO/DO/PO</p>
<ul>
<li>三者对应Controller、Service、Repository层的数据对象</li>
<li>每层都单独定义更好</li>
<li>可以抽象出一些通用结构解决复用性问题</li>
<li>可以提供一些工具类实现O之间的转化</li>
<li>DTO/PO可以定义为贫血模型，因为生存期较短，且不涉及复杂的业务逻辑</li>
<li>业务简单时，DO可以使用贫血模型，业务逻辑复杂时，最好使用充血模型</li>
</ul>
</li>
</ul>
<h5 id="案例接口调用统计框架"><strong>案例：接口调用统计框架</strong></h5>
<ul>
<li>
<p>需求分析</p>
<ul>
<li>功能性需求
<ul>
<li>接口统计信息：接口响应时间的统计信息、接口调用次数的统计信息</li>
<li>统计信息的类型：max、min、avg、count、tps等</li>
<li>统计信息显示格式：json、html、自定义</li>
<li>统计信息显示终端：console、email、http、日志</li>
<li>统计触发方式：主动触发、被动触发</li>
<li>统计时间区间</li>
<li>统计时间间隔</li>
</ul>
</li>
<li>非功能性需求
<ul>
<li>易用性</li>
<li>性能</li>
<li>扩展性
<ul>
<li>框架使用者可以较为方便的添加自定义插件</li>
</ul>
</li>
<li>容错性</li>
<li>通用性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>框架设计</p>
<ul>
<li>Prototype
<ul>
<li>聚焦一个简单的应用场景，设计实现一个简单的原型</li>
</ul>
</li>
<li>模块划分
<ul>
<li>数据采集：打点采集原始数据，记录响应时间和请求时间；高度容错，不能影响接口本身的可用性；易于使用</li>
<li>存储：将采集的原始数据保存下来；减少对接口本身性能的影响，异步存储</li>
<li>聚合统计：将原始数据聚合为统计数据；可扩展、以便支持更多规则</li>
<li>显示：将统计数据以某种格式显示到终端</li>
</ul>
</li>
</ul>
</li>
<li>
<p>开发实现</p>
<ul>
<li>小步快跑、快速迭代</li>
<li>划分职责进而识别出有哪些类</li>
</ul>
</li>
</ul>
<h3 id="编程规范与重构"><strong>编程规范与重构</strong></h3>
<h4 id="概括"><strong>概括</strong></h4>
<h5 id="定义"><strong>定义</strong></h5>
<ul>
<li>
<p>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低</p>
</li>
<li>
<p>重构是在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量</p>
</li>
</ul>
<h5 id="目的"><strong>目的</strong></h5>
<ul>
<li>
<p>重构是持续保证代码质量的有效手段</p>
</li>
<li>
<p>随着业务的发展，系统的演进也是不可避免的</p>
</li>
<li>
<p>重构是避免过度设计的有效手段</p>
</li>
</ul>
<h5 id="对象"><strong>对象</strong></h5>
<ul>
<li>
<p>大型重构</p>
<ul>
<li>概念：对顶层代码设计的重构，包括系统、模块、代码结构、类与类之间的关系等的重构</li>
<li>手段：分层、模块化、解耦、抽象可复用组件</li>
</ul>
</li>
<li>
<p>小型重构</p>
<ul>
<li>概念：对类、函数、变量等代码级别的重构</li>
<li>手段：规范命名、规范注释、消除超大类或函数、提取重复代码</li>
</ul>
</li>
</ul>
<h5 id="时机"><strong>时机</strong></h5>
<ul>
<li>
<p>原则：可持续、可演进</p>
</li>
<li>
<p>持续重构，把重构作为开发的一部分，作为开发规范的一部分，作为开发习惯的一部分</p>
</li>
<li>
<p>时刻具有重构意识，避免开发初期过度设计、避免代码维护过程中质量下降</p>
</li>
</ul>
<h4 id="单元测试"><strong>单元测试</strong></h4>
<ul>
<li>
<p>概念</p>
<ul>
<li>单元测试：对象是类或者函数，用来测试一个类或函数是否按照预期的逻辑执行</li>
<li>集成测试：对象是整个系统或功能模块</li>
</ul>
</li>
<li>
<p>意义</p>
<ul>
<li>有效检查代码bug，提高代码质量</li>
<li>帮助发现代码设计问题</li>
<li>对集成测试的有力补充，覆盖各种边界情况</li>
<li>帮助快速熟悉代码</li>
<li>是TDD可落地执行的改进方案</li>
</ul>
</li>
<li>
<p>避免：不经过单元测试和严格CR，通过 黑盒测试 发现问题再修改，测不出的问题在线上出问题时再修复</p>
</li>
</ul>
<h4 id="可测试性"><strong>可测试性</strong></h4>
<ul>
<li>
<p>概念</p>
<ul>
<li>针对代码编写单元测试的难易程度</li>
</ul>
</li>
<li>
<p>手段</p>
<ul>
<li>依赖注入是编写可测试代码的最有效手段，通过依赖注入，可通过mock的方式解决外部依赖</li>
<li>mock原因：外部对象参与逻辑执行、但又不受我们控制</li>
</ul>
</li>
<li>
<p>anti-patterns</p>
<ul>
<li>未决行为
<ul>
<li>含有当前时间、随机数等逻辑的方法</li>
<li>将未决行为单独抽离</li>
</ul>
</li>
<li>全局变量</li>
<li>静态方法</li>
<li>复杂继承</li>
<li>高耦合代码</li>
</ul>
</li>
</ul>
<h4 id="解耦"><strong>解耦</strong></h4>
<h5 id="概要"><strong>概要</strong></h5>
<ul>
<li>
<p>解耦，控制软件复杂度的方式，保证代码高内聚、低耦合，确保代码不至于复杂到难以维护的程度</p>
</li>
<li>
<p>高内聚、低耦合</p>
<ul>
<li>功能聚焦在某一模块或类中，降低阅读和修改代码的难度</li>
<li>修改代码时改动集中，降低引入bug的风险</li>
<li>使代码可测试性更好</li>
</ul>
</li>
<li>
<p>手段</p>
<ul>
<li>封装与抽象
<ul>
<li>隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口</li>
</ul>
</li>
<li>中间层
<ul>
<li>引入中间层简化模块或类之间的依赖关系</li>
</ul>
</li>
<li>模块化</li>
<li>单一职责原则
<ul>
<li>单一职责的类，依赖和被依赖的类会比较少，进而降低代码耦合度</li>
</ul>
</li>
<li>面向接口而非实现编程
<ul>
<li>通过接口中间层隔离变化和具体的实现，在有依赖关系的两个模块或类之间，一方改动不会影响到另一方</li>
<li>本质：将强依赖关系解耦为弱依赖关系，易于插拔替换</li>
</ul>
</li>
<li>依赖注入
<ul>
<li>将强依赖关系解耦为弱依赖关系，易于插拔替换</li>
</ul>
</li>
<li>迪米特法则</li>
</ul>
</li>
</ul>
<h4 id="编程规范-1"><strong>编程规范</strong></h4>
<h5 id="命名"><strong>命名</strong></h5>
<ul>
<li>
<p>核心：准确达意前提下，越短越好</p>
</li>
<li>
<p>长度</p>
<ul>
<li>常见词可使用缩写，如sec-&gt;second，num-&gt;number</li>
<li>作用域小的变量，可以使用相对短的命名</li>
<li>作用域大的变量、模块、类，需要使用长的命名</li>
</ul>
</li>
<li>
<p>利用上下文简化命名</p>
<ul>
<li>类属性不要重复类名</li>
<li>函数参数不必重复函数名称</li>
</ul>
</li>
<li>
<p>命名必须可读可搜索</p>
<ul>
<li>避免使用生僻、难发音的英文单词</li>
<li>通用操作使用项目/团队内统一的命名，如查询统一用query，插入统一用insert</li>
</ul>
</li>
<li>
<p>接口和抽象类</p>
<ul>
<li>接口可选统一加入前缀I，对应实现类加后缀Impl</li>
<li>抽象类可选统一加前缀Abstract</li>
<li>均可选，但需要项目内统一</li>
</ul>
</li>
</ul>
<h5 id="注释"><strong>注释</strong></h5>
<ul>
<li>
<p>核心：使代码更易看懂</p>
</li>
<li>
<p>注释应包括：做什么、为什么、怎么做，对一些边界情况、特殊情况进行说明，以及对函数输入、输出、异常进行说明</p>
</li>
<li>
<p>注释适量，过少难以阅读代码，过多难以维护</p>
</li>
<li>
<p>类和函数一定要写注释，而且要写的全面详细</p>
</li>
<li>
<p>函数内部注释要相对少一些，通过好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性</p>
</li>
</ul>
<h5 id="代码风格"><strong>代码风格</strong></h5>
<ul>
<li>
<p>类、函数的大小</p>
<ul>
<li>一个函数长度不要超过一屏</li>
<li>一行代码长度不要超过一屏</li>
<li>类的长度过长时：实现功能时无法确定使用哪个函数、想用的函数不容易找到、只用到一个小功能却要引入整个类</li>
</ul>
</li>
<li>
<p>善用空行分割单元块</p>
</li>
</ul>
<h5 id="编程技巧"><strong>编程技巧</strong></h5>
<ul>
<li>
<p>把代码分割成更小的单元块</p>
</li>
<li>
<p>避免函数参数过多</p>
<ul>
<li>拆分多个函数来减少参数</li>
<li>将函数的参数封装成对象</li>
</ul>
</li>
<li>
<p>不用函数参数来控制逻辑</p>
<ul>
<li>不用布尔值或是否为null来控制逻辑</li>
<li>特例：对于private函数、且拆分后的两个函数经常同时被使用，则可保留参数</li>
</ul>
</li>
<li>
<p>函数设计要职责单一</p>
</li>
<li>
<p>移除过深的嵌套层次</p>
<ul>
<li>去掉多余的if、else</li>
<li>利用continue、break、return等关键字提前退出嵌套</li>
<li>调整执行顺序来减少嵌套</li>
<li>将部分嵌套逻辑封装成函数调用</li>
</ul>
</li>
<li>
<p>使用解释性变量</p>
<ul>
<li>常量代替魔法数字</li>
<li>解释性变量来解释复杂表达式</li>
</ul>
</li>
</ul>
<h4 id="案例实践-1"><strong>案例实践</strong></h4>
<h5 id="标准-1"><strong>标准</strong></h5>
<ul>
<li>
<p>通用标准</p>
<ul>
<li>目录设置是否合理、模块划分是否清晰、代码结构是否满足高内聚、低耦合</li>
<li>是否遵循经典的设计原则和设计思想</li>
<li>设计模式是否应用得当，是否有过度设计</li>
<li>代码是否易于扩展，如果添加新功能，是否容易实现</li>
<li>代码是否可以复用、是否重复造轮子</li>
<li>代码是否易于测试，单元测试是否全面覆盖了各种正常和异常的情况</li>
<li>代码是否易读，是否符合编码规范</li>
</ul>
</li>
<li>
<p>业务标准</p>
<ul>
<li>代码是否实现了预期的业务需求</li>
<li>逻辑是否正确、是否处理了各种异常情况</li>
<li>日志打印是否得当、是否方便debug排查问题</li>
<li>接口是否易用、是否支持幂等、事务</li>
<li>代码是否存在并发问题、是否线程安全</li>
<li>性能是否有优化空间</li>
<li>是否有安全漏洞</li>
</ul>
</li>
</ul>
<h5 id="程序出错返回"><strong>程序出错返回</strong></h5>
<ul>
<li>异常情况下，如何返回异常
<ul>
<li>返回错误码
<ul>
<li>直接返回错误码，或者将错误码设置到全局变量</li>
</ul>
</li>
<li>返回NULL值
<ul>
<li>缺点：接收方需要做null值判断、影响代码正常逻辑和可读性</li>
<li>建议：对于get、query等查找不存在的记录，可以返回null或特殊值如-1</li>
</ul>
</li>
<li>返回空对象</li>
<li>抛出异常对象
<ul>
<li>优点：携带更多异常信息；将正常逻辑和异常逻辑分离开来，提高代码可读性</li>
<li>建议：在Java中，对于代码bug和不可恢复的异常(如数据库连接失败)，使用Unchecked异常直接抛出；对于可恢复异常、业务异常，使用checked异常强制调用者捕获处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="重构"><strong>重构</strong></h5>
<ul>
<li>
<p>扩展性</p>
<ul>
<li>依赖接口，通过依赖注入的方式注入接口实现</li>
<li>通过继承复用流程操作</li>
</ul>
</li>
<li>
<p>易用性</p>
<ul>
<li>提供封装了默认依赖的构造函数，内部自行初始化接口实现</li>
<li>默认依赖的配置信息可通过配置类读取</li>
</ul>
</li>
<li>
<p>性能</p>
<ul>
<li>异步执行、线程或消息队列</li>
<li>计算可分治</li>
</ul>
</li>
<li>
<p>容错性</p>
</li>
</ul>
<h2 id="设计模式与范式"><strong>设计模式与范式</strong></h2>
<ul>
<li>本质
<ul>
<li>设计模式的本质是解耦：以一种易维护、易读、易扩展、易用、易复用的方式实现代码之间的依赖。创建型模式将创建和使用代码解耦；结构型模式将不同功能代码解耦；行为型模式将不同行为代码解耦。</li>
</ul>
</li>
</ul>
<h3 id="创建型"><strong>创建型</strong></h3>
<h4 id="单例模式"><strong>单例模式</strong></h4>
<h5 id="概要-1"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：一个类在程序的生命周期只允许创建一个实例</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>处理资源访问冲突、节省系统资源</li>
<li>表示全局唯一类：业务概念上只能存在一个实例的类</li>
</ul>
</li>
</ul>
<h5 id="实现"><strong>实现</strong></h5>
<ul>
<li>
<p>构造函数通过private修饰，避免外部创建实例</p>
</li>
<li>
<p>提供静态方法以提供单例对象</p>
</li>
<li>
<p>考虑实例创建时的线程安全问题、考虑是否延迟加载、考虑getInstance性能是否高</p>
</li>
<li>
<p>饿汉式</p>
<ul>
<li>在类加载时，创建并初始化实例</li>
<li>不支持延迟加载</li>
</ul>
</li>
<li>
<p>懒汉式</p>
<ul>
<li>在实际调用getInstance方法时，才会创建并初始化实例</li>
<li>并发性能不高</li>
</ul>
</li>
<li>
<p>double-check</p>
<ul>
<li>在getInstance方法中，首先检查实例是否创建，未创建时再加锁，加锁成功后再检查实例是否创建，未创建时才真正创建并保存到类中</li>
<li>支持延迟加载、并发性能提升</li>
</ul>
</li>
<li>
<p>静态内部类</p>
<ul>
<li>单例类内部定义静态内部类，静态内部类内部在类初始化中创建单例类实例</li>
<li>利用Java特性：外部类加载时并不加载静态内部类，从而不会创建单例类实例，当getInstance真正访问静态内部类时，内部类才会被加载，此时才会创建单例类实例，同时类加载的线程安全性由JVM来保证</li>
</ul>
</li>
<li>
<p>枚举</p>
<ul>
<li>利用Java枚举类本身的特性，无需提供getInstance方法，直接访问枚举对象来实现单例</li>
</ul>
</li>
</ul>
<h5 id="问题"><strong>问题</strong></h5>
<ul>
<li>
<p>单例模式对OOP特性的支持不友好</p>
<ul>
<li>对OOP的抽象、继承、多态支持不友好</li>
</ul>
</li>
<li>
<p>单例模式会隐藏类之间的依赖关系</p>
<ul>
<li>解决：将单例实例通过依赖注入的方式传递给实用类</li>
</ul>
</li>
<li>
<p>单例模式对代码的扩展性不好</p>
</li>
<li>
<p>单例模式对代码的可测试性不友好</p>
</li>
<li>
<p>单例模式不支持有参数的构造函数</p>
<ul>
<li>解决
<ul>
<li>先执行init创建单例实例，再通过getInstance获取实例</li>
<li>将参数放到getInstance中，但会导致后续设置不起作用</li>
<li>将参数放到全局变量中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>解决</p>
<ul>
<li>通过其他方式：工厂模式、IOC容器、程序自己保证等方式实现全局唯一类</li>
</ul>
</li>
</ul>
<h5 id="权衡-3"><strong>权衡</strong></h5>
<ul>
<li>单例类无后续扩展需求，不依赖外部系统，则可以设计成单例类，避免将单例实例在类之间传来传去</li>
</ul>
<h5 id="扩展"><strong>扩展</strong></h5>
<ul>
<li>
<p>单例模式中唯一性的范围</p>
<ul>
<li>默认：进程内唯一</li>
<li>其他：线程内唯一：通过ThreadLocal或通过ConcurrentHashMap根据线程ID来实现</li>
<li>其他：集群内唯一：通过分布式锁+序列化文件来实现，保证任一时刻，集群内只有一个线程持有单例实例</li>
</ul>
</li>
<li>
<p>多例模式</p>
<ul>
<li>一个类可以创建限定个数的实例 or 一个类对于指定的参数只能创建一个实例</li>
<li>通过ConcurrentHashMap实现</li>
</ul>
</li>
</ul>
<h4 id="工厂模式"><strong>工厂模式</strong></h4>
<ul>
<li>
<p>本质：类的构建和使用分离，使用者无需关心类的具体类型和构建过程</p>
<ul>
<li>隔离复杂性：类使用者既不用关心要创建哪个类，也不必关心如何创建该类，只需通过工厂模式获取即可</li>
<li>封装变化：类创建逻辑的变更对类的使用者透明</li>
<li>代码复用：类创建逻辑复用</li>
<li>控制复杂度：将创建代码抽离出来，使得类的职责更单一、代码更简洁</li>
</ul>
</li>
<li>
<p>用途</p>
<ul>
<li>创建对象时需要通过复杂的if-else判断要创建哪个类</li>
<li>创建对象时需要组装多个其他类的对象或者需要复杂的初始化流程</li>
</ul>
</li>
</ul>
<h5 id="简单工厂模式"><strong>简单工厂模式</strong></h5>
<ul>
<li>
<p>概念：定义一个工厂类，提供一个静态方法，该方法根据参数的不同返回不同产品类的实例</p>
</li>
<li>
<p>实现</p>
<ul>
<li>静态方法内部通过if-else判断要实例化哪个产品类</li>
<li>根据产品类特性
<ul>
<li>每次调用都产生一个新的产品类实例</li>
<li>预先为每个产品类产生一个实例，每次调用都返回之前已经创建的产品实例（单例）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对于对象创建逻辑较为简单的类，可通过简单工厂模式实现</p>
</li>
</ul>
<h5 id="工厂方法模式"><strong>工厂方法模式</strong></h5>
<ul>
<li>
<p>概念：定义一个用于创建对象的工厂接口，由实现此工厂接口的类来决定实例化哪个产品类</p>
</li>
<li>
<p>实现</p>
<ul>
<li>通过配置文件+反射调用相应的工厂类</li>
<li>通过定义创建工厂的工厂类，此工厂类可通过map+工厂实现类单例的方式省去if-else判断</li>
</ul>
</li>
<li>
<p>对于对象创建逻辑较为复杂的类，可通过工厂方法模式将每个产品类的创建逻辑拆分到不同的工厂类中</p>
</li>
</ul>
<h5 id="抽象工厂模式"><strong>抽象工厂模式</strong></h5>
<ul>
<li>
<p>概念：定义一个创建一系列相关的对象（产品族）的工厂接口，由实现此工厂接口的类来决定实例化哪些类</p>
</li>
<li>
<p>实现</p>
<ul>
<li>同工厂方法</li>
</ul>
</li>
<li>
<p>工厂方法模式是在一类产品的不同实现上扩展；抽象工厂模式是在一组产品的相同实现上扩展</p>
</li>
</ul>
<h5 id="di容器"><strong>DI容器</strong></h5>
<ul>
<li>DI容器负责整个应用中所有类对象的创建
<ul>
<li>配置解析
<ul>
<li>通过读取配置文件，根据配置信息确定要创建哪些对象</li>
</ul>
</li>
<li>对象创建
<ul>
<li>将所有类对象的创建放到一个工厂类BeansFactory中，根据反射的方式动态的加载类、创建对象</li>
</ul>
</li>
<li>对象生命周期管理
<ul>
<li>配置对象是单例还是每次新创建、是否支持懒加载、对象的初始化和销毁方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="建造者模式"><strong>建造者模式</strong></h4>
<h5 id="概要-2"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：将一个复杂对象的构建和表示分离，从而使得同样的构建过程可以创建不同的表示</p>
</li>
<li>
<p>本质：类的构建和表示(类本身的功能)分离，使用者可以方便的设置所需参数，无需关心复杂的构造过程</p>
</li>
<li>
<p>实现</p>
<ul>
<li>传统：定义一个Builder接口，为每种复杂对象类定义一个Builder实现类，通过Director类调用Builder实现类进行构建，然后返回复杂对象</li>
<li>常用：定义一个Builder静态内部类，提供类的各字段的setter方法，提供build方法进行创建前的校验和实例的创建</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>复杂对象的构建
<ul>
<li>有大量必填参数，通过构造函数构建时可读性差</li>
<li>有大量可选参数，但部分可选参数存在相互依赖或者约束条件</li>
<li>希望对象构建后不可变，即setter方法私有</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="原型模式"><strong>原型模式</strong></h4>
<h5 id="概要-3"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：通过复制原型实例的方式创建新对象</p>
</li>
<li>
<p>实现</p>
<ul>
<li>浅拷贝：复制基本类型数据和引用对象的内存地址</li>
<li>深拷贝：复制基本类型数据和引用对象本身，以及递归深拷贝引用对象</li>
<li>序列化：序列化到文件或内存，然后再反序列化</li>
<li>推荐：不可变对象、或者对象和原型之间无需更改的对象可用浅拷贝，否则必须用深拷贝</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>对象创建成本很大，而对象和原型之间的大部分字段相同
<ul>
<li>对象中的数据需要复杂计算、或者从RPC、网络、数据库等慢速IO中读取</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="结构型"><strong>结构型</strong></h3>
<h4 id="代理模式"><strong>代理模式</strong></h4>
<h5 id="概要-4"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：为原始类提供代理类，通过代理类控制对原始类的访问</p>
</li>
<li>
<p>实现</p>
<ul>
<li>静态代理
<ul>
<li>组合：代理类实现原始类的接口，通过依赖注入的方式注入原始类实例</li>
<li>继承：代理类继承原始类，重写public方法</li>
</ul>
</li>
<li>动态代理
<ul>
<li>不事先为每个类编写代理类，在运行时动态创建代理类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>业务系统的非业务功能性需求开发，如监控、统计、鉴权、限流</li>
<li>RPC框架作为远程代理</li>
<li>通过代理实现缓存</li>
</ul>
</li>
</ul>
<h4 id="桥接模式"><strong>桥接模式</strong></h4>
<h5 id="概要-5"><strong>概要</strong></h5>
<ul>
<li>
<p>定义</p>
<ul>
<li>原始：将抽象和实现解耦，让它们可以独立变化
<ul>
<li>抽象和实现 对应两种不同的独立变化的维度，二者通过组合的方式桥接在一起</li>
</ul>
</li>
<li>通用：一个类存在两个或多个独立变化的维度，通过组合的方式，让这两个维度可以独立的进行扩展</li>
</ul>
</li>
<li>
<p>实现</p>
<ul>
<li>一个维度通过抽象类实现，另一个维度通过接口类实现，二者通过组合的方式进行依赖，即接口类对象作为抽象类的一个属性</li>
</ul>
</li>
<li>
<p>JDBC</p>
<ul>
<li>一般把JDBC视为桥接模式的经典实现，但是在JDBC中实际只有Driver一个变化维度，Driver作为DriverManger的一个属性，但是DriverManger本身没有变化
<ul>
<li>一种理解：可以将DriverManager视为JDBC规范的一个实现，即JDBC规范是另一个独立变化的维度</li>
<li>二种理解：JDBC是一种简化的桥接模式，实际上只有一种变化维度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="装饰器模式"><strong>装饰器模式</strong></h4>
<h5 id="概要-6"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：在不改变原有对象的基础上，动态地给一个对象添加增强功能</p>
</li>
<li>
<p>本质：利用组合替代继承，给原始类添加增强功能</p>
</li>
<li>
<p>实现</p>
<ul>
<li>装饰器类和原始类继承相同的抽象类或实现相同的接口；原始类通过依赖注入的方式注入到装饰器类中</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>扩展一个类的功能</li>
<li>动态的、连续的给一个对象添加功能，对象具有的功能等到运行时才真正确定</li>
</ul>
</li>
<li>
<p>区别</p>
<ul>
<li>装饰器模式和代理模式 二者的实现方式类似，但思想不同
<ul>
<li>装饰器模式侧重为所装饰的类提供增强功能，而且可以叠加嵌套</li>
<li>代理模式侧重对所代理的对象施加访问控制，并不提供对象本身的增强功能，一般用在端点，不再叠加</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="适配器模式"><strong>适配器模式</strong></h4>
<h5 id="概要-7"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而导致无法一起工作的两个类可以一起工作</p>
</li>
<li>
<p>实现</p>
<ul>
<li>类适配器
<ul>
<li>适配器类继承原始类，实现目标接口，在接口方法中调用父类相应方法</li>
</ul>
</li>
<li>对象适配器
<ul>
<li>适配器类通过组合方式注入原始类实例，实现目标接口，在接口方法中调用原始类实例的相应方法</li>
</ul>
</li>
<li>权衡
<ul>
<li>原始类接口不多时，都可</li>
<li>原始类接口很多，且原始类和目标接口大部分接口都相同，则通过类适配器实现</li>
<li>原始类接口很多，且原始类和目标接口大部分不同，则通过对象适配器实现</li>
</ul>
</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>本质：适配器模式是一种补偿模式，用来弥补设计上的缺陷</li>
<li>封装有缺陷的接口设计
<ul>
<li>依赖的外部类在接口设计上有缺陷，如大量静态方法，则可自定义更好的接口，然后定义适配器类封装外部类</li>
</ul>
</li>
<li>统一多个类的接口设计
<ul>
<li>依赖多个(相同功能)外部类实现某一功能，但外部类/接口的定义不同，则可自定义统一的接口，然后定义适配器类封装外部类，然后内部类就可只依赖自定义接口，隔离外部类的变化</li>
</ul>
</li>
<li>替换依赖的外部系统
<ul>
<li>替换依赖的外部接口时，可定义适配器类实现原外部接口，同时使用新外部类实现功能</li>
</ul>
</li>
<li>兼容老版本接口
<ul>
<li>不直接删除待废弃的接口，而是将其内部逻辑委托给新的接口实现</li>
</ul>
</li>
<li>适配不同格式的数据</li>
</ul>
</li>
</ul>
<h4 id="门面模式"><strong>门面模式</strong></h4>
<h5 id="概要-8"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：为子系统提供一组统一的接口，定义一组高层接口让子系统更易用</p>
</li>
<li>
<p>实现：在提供细粒度接口的同时，根据实际需要增加高层接口组装底层接口</p>
</li>
<li>
<p>场景</p>
<ul>
<li>解决易用性问题
<ul>
<li>封装系统的底层实现，隐藏系统的复杂性，提供一组更简单易用、更高层的接口</li>
</ul>
</li>
<li>解决性能问题
<ul>
<li>将多个接口替换为一个门面接口调用，减少网络通信成本</li>
<li>门面接口不多时，可直接将门面接口和非门面接口放到一组；否则，可再抽象出一层接口</li>
</ul>
</li>
<li>解决分布式事务问题
<ul>
<li>把不可分的操作放到一个门面接口实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="组合模式"><strong>组合模式</strong></h4>
<h5 id="概要-9"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：将一组对象组织成树形结构，以表示一种部分-整体的层次结构，让客户端可以统一对单个对象和组合对象的处理逻辑</p>
</li>
<li>
<p>实现：叶子结点对象和中间节点对象都继承/实现同一个抽象类，中间节点对象在具体实现时注入抽象类对象列表，以此实现树的构建；通过递归的方式建树并实现功能</p>
</li>
<li>
<p>场景</p>
<ul>
<li>数据可以表示成树这种数据结构，业务需求可通过在树上的递归算法来实现</li>
</ul>
</li>
</ul>
<h4 id="享元模式"><strong>享元模式</strong></h4>
<h5 id="概要-10"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：共享细粒度不可变对象，实现对象复用</p>
</li>
<li>
<p>本质：缓存共享对象，降低内存消耗和重复构建造成的性能损失</p>
</li>
<li>
<p>实现：将原始类中存在大量重复的字段封装成享元类，通过工厂模式在工厂类中通过Map或List缓存已经创建好的享元类对象，原始类通过享元工厂获取并共享享元对象</p>
</li>
<li>
<p>场景：大量对象存在重复字段、重复字段改动很小</p>
</li>
<li>
<p>区别</p>
<ul>
<li>享元的目的是实现共享复用节约内存，池化技术侧重重复使用节约时间</li>
<li>单例保证对象全局唯一，享元则保证属性相同的对象共享使用</li>
</ul>
</li>
</ul>
<h3 id="行为型"><strong>行为型</strong></h3>
<h4 id="观察者模式"><strong>观察者模式</strong></h4>
<h5 id="概要-11"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p>
</li>
<li>
<p>本质：将状态变化和状态响应分离</p>
</li>
<li>
<p>实现</p>
<ul>
<li>被观察者提供注册方法注入观察者对象；观察者对象实现观察接口进行自定义操作；被观察者状态发生变化时遍历观察者对象并调用处理方法</li>
<li>被观察者调用观察者的方式
<ul>
<li>同步阻塞
<ul>
<li>观察者在同一个线程内依次遍历并调用被观察者</li>
</ul>
</li>
<li>异步非阻塞
<ul>
<li>启动新的线程遍历并调用被观察者</li>
<li>被观察者启动新线程执行自定义操作</li>
<li>通过EventBus实现</li>
<li>通过消息队列组件通知跨进程的观察者</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="框架"><strong>框架</strong></h5>
<ul>
<li>
<p>EventBus，提供实现观察者模式的骨架代码</p>
<ul>
<li>定义Observer，Observer可以是任意Object</li>
<li>EventBus通过register注册Observer、通过unregister删除Observer</li>
<li>EventBus通过post向匹配的Observer发送event</li>
<li>Observer通过Subscribe注解标明事件处理函数</li>
</ul>
</li>
<li>
<p>实现</p>
<ul>
<li>Subscribe
<ul>
<li>注解类，用于标明观察者的哪个函数用来接受消息</li>
</ul>
</li>
<li>ObserverAction
<ul>
<li>标明Subscribe注解修饰的方法，主要用在ObserverRegistry观察者注册表中</li>
</ul>
</li>
<li>ObserverRegistry
<ul>
<li>实现register方法，将Observer添加到观察者注册表</li>
</ul>
</li>
<li>EventBus
<ul>
<li>暴露接口</li>
</ul>
</li>
</ul>
</li>
<li>
<p>框架：隐藏实现细节、降低开发难度、做到代码复用、解耦业务与非业务代码，让程序员聚焦业务开发</p>
</li>
</ul>
<h4 id="模板模式"><strong>模板模式</strong></h4>
<h5 id="概要-12"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>
</li>
<li>
<p>实现：</p>
<ul>
<li>经典：父类定义一个final方法作为模板方法，内部调用abstract方法，子类重写abstract方法实现扩展</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>复用
<ul>
<li>复用父类的模板逻辑</li>
</ul>
</li>
<li>扩展
<ul>
<li>在不改变框架源码的情况下，定制化框架的功能</li>
</ul>
</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>框架开发，用于提供功能扩展点，让框架用户在不修改源码的情况下，基于扩展点定制化框架功能</li>
</ul>
</li>
</ul>
<h5 id="回调"><strong>回调</strong></h5>
<ul>
<li>
<p>A类将回调函数注册到B类方法中，从而在A类调用B类方法时，B类方法又反过来调用A注册的回调函数</p>
</li>
<li>
<p>回调和模板模式类似，回调函数类似模板模式中的abstract方法，回调函数注册到的函数即为模板函数</p>
</li>
<li>
<p>回调方式</p>
<ul>
<li>同步回调：在函数返回之前执行回调函数</li>
<li>异步回调：在函数返回之后执行回调函数</li>
</ul>
</li>
<li>
<p>对比：模板vs回调</p>
<ul>
<li>场景类似：在某一方法的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的</li>
<li>实现不同：模板基于继承，回调基于组合</li>
<li>模板模式中子类不可再继承</li>
<li>模板模式中针对每种不同的实现都要定义子类</li>
<li>模板模式中如果定义多个模板方法，则子类必须实现全部抽象方法</li>
<li>模板模式中能利用父类提供的属性等能力，而回调中无法利用主函数</li>
</ul>
</li>
</ul>
<h4 id="策略模式"><strong>策略模式</strong></h4>
<h5 id="概要-13"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：定义一组算法类，将每个算法分别封装起来，让它们可以相互替换</p>
</li>
<li>
<p>本质：策略模式解耦策略的定义、创建、使用</p>
</li>
<li>
<p>实现</p>
<ul>
<li>定义策略
<ul>
<li>定义一个策略接口和一组实现这个接口的策略类</li>
</ul>
</li>
<li>创建策略
<ul>
<li>定义一个策略工厂，根据策略类型创建并返回策略实例</li>
<li>根据策略是否有状态
<ul>
<li>提前创建策略实例放到map中获取单一实例</li>
<li>通过if-else判断，每次创建新实例</li>
</ul>
</li>
</ul>
</li>
<li>使用策略
<ul>
<li>运行时动态确定使用哪种策略
<ul>
<li>运行时直接获取到策略类型</li>
<li>运行时根据参数if-else判断策略类型</li>
<li>策略提供判断方法accept，只有accept返回true时才进行处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>场景：根据需求不断扩展策略</p>
</li>
</ul>
<h4 id="职责链模式"><strong>职责链模式</strong></h4>
<h5 id="概要-14"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：将请求的发送和接受解耦，让多个接收对象都有机会处理这个请求，将这些接收对象串成一条链，并沿着链传递该请求，直到链上的某个接收对象能够处理它为止。</p>
</li>
<li>
<p>实现</p>
<ul>
<li>链表实现
<ul>
<li>定义抽象父类Handler，类中包含抽象处理方法handle，同时包含后继接收对象Handler字段</li>
<li>定义多个子类继承Handler，在handle中处理请求，如果能处理该请求，则不再传递给后继对象，否则，传递给后继对象继续处理</li>
<li>定义职责链类，类提供add添加Handler，并通过Handler的后继组成链表，然后提供handle方法从职责链头结点开始处理</li>
</ul>
</li>
<li>数组实现
<ul>
<li>定义接口Handler</li>
<li>定义职责链类，内部包含Handler列表，处理时从头遍历，如果已处理则break</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变体</p>
<ul>
<li>原始定义中，当某一接受对象能够处理请求时不再向后传递请求</li>
<li>变体：请求会被所有的处理器处理一遍</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>敏感词过滤</li>
<li>拦截器</li>
<li>框架提供职责链类，从而使得用户在不改变框架源码的前提下可以增加处理器自定义拦截、过滤逻辑</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>拆分处理器类，满足单一职责原则，降低复杂性</li>
<li>满足开闭原则，提高代码扩展性</li>
</ul>
</li>
</ul>
<h4 id="状态模式"><strong>状态模式</strong></h4>
<h5 id="概要-15"><strong>概要</strong></h5>
<ul>
<li>定义：实现状态机时，将事件触发的状态转移和动作执行，拆分到不同的状态类中，避免分支判断逻辑</li>
</ul>
<h5 id="状态机"><strong>状态机</strong></h5>
<ul>
<li>
<p>有限状态机：有限个状态以及在这些状态之间的转移和动作等行为的模型</p>
<ul>
<li>状态</li>
<li>事件</li>
<li>动作</li>
<li>事件触发状态转移及动作的执行</li>
</ul>
</li>
<li>
<p>实现方式</p>
<ul>
<li>分支逻辑法
<ul>
<li>在每个事件/处理函数中，根据状态机的流转图和当前所处的状态，更新状态、触发动作</li>
<li>对于复杂状态机，易漏写错写状态转移，也难以维护修改</li>
</ul>
</li>
<li>查表法
<ul>
<li>以当前状态和事件作为表的两个维度，分别以目标状态和触发行为作为表的内容，构建两个转移表</li>
<li>在每个事件处理函数中，只需查表得到目标状态和触发动作即可</li>
<li>易于维护，易于扩展；但触发动作复杂时有一定局限性</li>
</ul>
</li>
<li>状态模式
<ul>
<li>将事件触发的状态转移和动作执行，拆分到不同的状态类中，避免分支判断逻辑</li>
<li>实现
<ul>
<li>定义一个状态接口，接口中包含全部事件</li>
<li>定义一个状态机类，维护一个当前状态，当事件发生时，调用当前状态的事件方法即可</li>
<li>每种状态定义一个状态类，实现状态接口，状态类注入状态机，同时重写自己支持的事件接口方法，在该方法中实现状态机的状态转移，然后完成相应的动作</li>
<li>优化：将状态类作为单例类，将状态机类作为参数放置在事件方法</li>
</ul>
</li>
</ul>
</li>
<li>权衡
<ul>
<li>分支逻辑法：适合状态少、事件少、动作简单</li>
<li>查表法：适合状态多、事件多、转移复杂</li>
<li>状态模式：适合状态少、事件少、触发动作复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="迭代器模式"><strong>迭代器模式</strong></h4>
<h5 id="概要-16"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：提供一种按顺序访问集合、容器对象元素的方法，同时又无需暴露集合内部表示</p>
</li>
<li>
<p>实现</p>
<ul>
<li>定义迭代器类，通过依赖注入方式传递容器类实例，定义hasNext、next、currentItem方法进行遍历</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>将复杂迭代逻辑拆分到迭代器类中，隔离复杂度</li>
<li>每个迭代器独享游标信息，支持多个迭代器同时进行遍历</li>
<li>基于迭代器接口，易于扩展新的迭代方式，更符合开闭原则</li>
</ul>
</li>
<li>
<p>问题</p>
<ul>
<li>在通过迭代器遍历集合时，增加、删除集合元素会导致不可预期的遍历结果
<ul>
<li>方案：增删元素后，让迭代器遍历报错</li>
</ul>
</li>
</ul>
</li>
<li>
<p>扩展</p>
<ul>
<li>支持快照功能的迭代器：为容器创建迭代器的时候，相当于为容器创建快照，之后即使在原容器增删元素，也不会影响迭代器的遍历和容器快照的数据</li>
<li>方案
<ul>
<li>在迭代器类中定义一个成员变量snapshot存储快照，创建时拷贝原容器数据到快照容器中
<ul>
<li>实现简单；代价高、增加内存消耗</li>
</ul>
</li>
<li>在容器中为每个元素增加两个时间戳：创建时间戳和删除时间戳；迭代器类中增加创建迭代器时的当前时间戳，迭代时只访问创建时间戳小于当前时间戳且删除时间戳为0或大于当前时间戳的元素
<ul>
<li>问题：无法实现容器的随机访问</li>
<li>解决：定义两个数组，一个数组真正删除，另一个数组不删除</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="访问者模式"><strong>访问者模式</strong></h4>
<h5 id="概要-17"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：允许一个或者多个操作作用到一组对象上，解耦操作和对象本身</p>
</li>
<li>
<p>实现</p>
<ul>
<li>一组数据子类继承自同一接口或父类</li>
<li>一组业务操作子类继承自访问者接口或父类Vistor，接口Vistor通过重载包含对全部对象的操作</li>
<li>数据子类提供accept方法，方法接受访问者类作为参数，然后将实例自身作为参数调用访问者类方法</li>
<li>访问者类中通过重载实现不同对象的不同操作</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>针对一组类型不同但继承同一父类、接口的对象，在不同的业务场景下，需要对这组对象进行一系列不相关的业务操作，但为了避免不断添加功能导致类不断膨胀、职责越来越多、修改越来越频繁、分散，访问者模式将对象和操作解耦，将业务操作抽离出来，分别定义在独立细分的访问者类中</li>
</ul>
</li>
<li>
<p>对比</p>
<ul>
<li>可以将一组相同操作分别针对不同的目标类型定义到独立的类，然后通过工厂模式返回相应的操作类
<ul>
<li>目标类型多、操作多时需要定义大量的类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="dispatch"><strong>Dispatch</strong></h5>
<ul>
<li>
<p>Single Dispatch</p>
<ul>
<li>执行哪个对象的方法，在运行时根据对象的运行时类型确定</li>
<li>执行该对象的哪个方法，在编译时根据方法参数的编译时类型确定</li>
</ul>
</li>
<li>
<p>Double Dispatch</p>
<ul>
<li>执行哪个对象的方法，在运行时根据对象的运行时类型确定</li>
<li>执行该对象的哪个方法，在运行时根据方法参数的运行时类型确定</li>
</ul>
</li>
</ul>
<h4 id="备忘录模式"><strong>备忘录模式</strong></h4>
<h5 id="概要-18"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>
</li>
<li>
<p>实现</p>
<ul>
<li>定义快照类Snapshot，用于保存主类对象的历史数据，同时只暴露get方法保证不变形</li>
<li>定义快照管理类，用于保存全部快照数据，同时提供pop、push接口</li>
<li>主类提供创建快照方法：返回快照；提供恢复快照方法：接受快照实例</li>
</ul>
</li>
<li>
<p>优化</p>
<ul>
<li>快照中只存储增量不存储全量</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>防丢失、撤销、恢复</li>
</ul>
</li>
</ul>
<h4 id="命令模式"><strong>命令模式</strong></h4>
<h5 id="概要-19"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：将命令封装为一个对象，这样可以将不同的命令依赖注入到其他对象，并且能够支持请求的排队执行、记录日志、撤销等功能</p>
</li>
<li>
<p>实现</p>
<ul>
<li>定义命令接口</li>
<li>不同的命令定义不同的命令类实现命令接口</li>
<li>根据客户端输入的命令操作调用不同的命令类实例</li>
</ul>
</li>
<li>
<p>场景</p>
<ul>
<li>控制命令的执行，如异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>请求的调用者和接收者解耦，二者通过命令对象交互</li>
</ul>
</li>
</ul>
<h4 id="解释器模式"><strong>解释器模式</strong></h4>
<h5 id="概要-20"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法</p>
</li>
<li>
<p>实现</p>
<ul>
<li>将语法解析的工作拆分到各个小类中</li>
<li>将语法规则拆分成一些小而独立的单元，对每个单元进行解析，最终合并为整个语法规则的解析</li>
</ul>
</li>
</ul>
<h4 id="中介模式"><strong>中介模式</strong></h4>
<h5 id="概要-21"><strong>概要</strong></h5>
<ul>
<li>
<p>定义：定义一个单独的中介对象，用来封装一组对象之间的交互，将这组对象之间的交互委派给中介对象交互，避免对象之间的直接交互</p>
</li>
<li>
<p>作用：实现参与者之间的解耦，简化交互关系</p>
</li>
<li>
<p>场景</p>
<ul>
<li>参与者之间的交互关系复杂，既可以时消息发送者，也可以是消息接收者</li>
</ul>
</li>
</ul>
<h3 id="原则"><strong>原则</strong></h3>
<h4 id="避免过度设计"><strong>避免过度设计</strong></h4>
<ul>
<li>
<p>设计的初衷是提高代码质量</p>
</li>
<li>
<p>设计的过程是先有问题后有方案</p>
</li>
<li>
<p>设计的应用场景是复杂代码</p>
</li>
<li>
<p>持续重构能有效避免过度设计</p>
</li>
</ul>
<h4 id="避免设计不足"><strong>避免设计不足</strong></h4>
<ul>
<li>
<p>一定的理论知识储备</p>
</li>
<li>
<p>一定的刻意训练</p>
</li>
<li>
<p>一定要有代码质量意识、设计意识</p>
</li>
</ul>
<h2 id="开源与项目实战"><strong>开源与项目实战</strong></h2>
<h3 id="开源实战"><strong>开源实战</strong></h3>
<h4 id="java-jdk"><strong>Java JDK</strong></h4>
<h5 id="calender"><strong>Calender</strong></h5>
<ul>
<li>
<p>Calendar类提供大量跟日期相关的功能代码，同时又提供了一个getInstance工厂方法，用来根据不同的TimeZone和Locale创建不同的Calendar子类对象</p>
</li>
<li>
<p>Calendar类同时通过内部静态Builder类实现建造者模式</p>
</li>
<li>
<p>工厂模式：创建不同但相关类型的对象；建造者模式：创建一种类型但构建复杂、通过设置可选参数创建同一类型但不同的对象</p>
</li>
</ul>
<h5 id="collections"><strong>Collections</strong></h5>
<ul>
<li>
<p>Collections类是一个集合容器的工具类，提供很多静态方法用来创建各种集合容器</p>
</li>
<li>
<p>Collections通过静态方法创建的UnmodifiedCollection类、CheckedCollection、SynchronizedCollection类都是针对Collection类的装饰器类</p>
</li>
<li>
<p>新版本JDK中，Enumeration作为适配器类，适配客户端类和Iterator类</p>
</li>
<li>
<p>Collections.sort方法通过模板模式，将比较大小这部分逻辑委托给用户实现</p>
<ul>
<li>实际上通过回调机制实现</li>
<li>也可以看做非典型策略模式</li>
</ul>
</li>
</ul>
<h5 id="runtime"><strong>Runtime</strong></h5>
<ul>
<li>
<p>每个JVM进程只对应一个Runtime实例，用来查看JVM状态以及控制JVM行为</p>
</li>
<li>
<p>饿汉式实现</p>
</li>
</ul>
      
      
    </div>

    
		<div class="post-cats-box">
      
      
      <a class="tag-link" href="/categories/%E6%8A%80%E6%9C%AF">技术</a> 
      
		</div>
		

    
    
    <div class="post-tags-box">
      
      
      <a class="tag-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a> 
      
    </div>
    
    

  </article>
</div>

<div class="post-nav">
  

  
  <div class="next-wrap col-md-6 col-xs-6">
    <a href="https://brycerd.github.io/posts/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" class="prev-post">程序架构设计基础</a>
    <i class="fa fa-angle-double-right"></i>
  </div>
  
</div>


    <div id="toc"></div>
    </main>
</div>


  <div id="local-search">
    <div class="search-dialog">
        <div class="search-nav">
            <span class="search-dialog-title">搜索</span>
            <span id="loading-status"></span>
            <button class="search-close-button">
                <i class="iconfont icon-quxiao4"></i>
            </button>
        </div>
        <div class="is-center" id="loading-database">
            <i class="fas fa-spinner fa-pulse"></i>
            <span>数据库载入中</span>
        </div>
        <div class="search-wrap">
            <div id="local-search-input">
                <div class="local-search-box">
                    <input class="local-search-box--input" placeholder="请输入关键词" type="text">
                </div>
            </div>
            <hr>
            <div id="local-search-results">
            </div>
        </div>
    </div>
    <div id="search-mask"></div>
</div>


<div id="login">
    <div class="login-box">
        <p class="login-nav">
            <span class="login-title">LOGIN</span>
            <span id="loading-status"></span>
            <button class="login-close-button">
                <i class="iconfont icon-quxiao4"></i>
            </button>
        </p>
		<div class="item">
			<input type="text" id="user" required>
			<label for="">USER</label>
		</div>
		<div class="item">
			<input type="password" id="password" required>
			<label for="">PASSWORD</label>
		</div>
		<button class="btn" id="login-submit">submit
			<span></span>
			<span></span>
			<span></span>
			<span></span>
		</button>
    </div>
    <div id="login-mask">
    </div>
</div>
<footer>
  <div class="copyright">
    <p id="copyright">Copyright © &nbsp;Bryce&nbsp;2022 - 2023&nbsp;
    </p>
    <p>
      Powered by
      <a href="https://gohugo.io/" target="_blank">Hugo</a>&nbsp;&
      <a href="https://github.com/GenkunAbe/hugo-theme-hiruko" target="_blank">Hiruko</a>
    </p>
  </div>
</footer>

<script>
(function (u, c) {
    var d = document, t = 'script', o = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(e); }); }
    s.parentNode.insertBefore(o, s);
})("/libs/pangu/pangu.min.js", function () {
    pangu.spacingPage();
});
</script>
<link rel="stylesheet" href="/libs/katex/css/katex.min.css">
<script defer src="/libs/katex/js/katex.min.js"></script>
<script defer src="/libs/katex/js/auto-render.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          macros: {
            "\\ge": "\\geqslant",
            "\\le": "\\leqslant",
            "\\geq": "\\geqslant",
            "\\leq": "\\leqslant"
            },
          
          throwOnError : false
        });
    });
</script>
<script>
    if (typeof show_toc == 'undefined') {
        var show_toc = true;
    }
    if (show_toc) {
        $("#toc").tocify({
            selectors: "h2,h3,h4,h5", 
            extendPage: false, 
            highlightDefault: true, 
            highlightOnScroll: true,
            scrollTo: 80,
        });
    }
</script>

<script src="/js/util.js"></script>
<script src="/js/crypto-js.min.js"></script>
<script src="/js/mask.js"></script>

<script src="/js/localsearch.js"></script></body>
</html>