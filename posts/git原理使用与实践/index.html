<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  
  <title>Git：原理、使用与实践 - Bryce&#39;s Log</title>
  <meta name="description" content="Git：原理、使用与实践">
  <meta name="keywords" content="[Git]">
  <meta name="author" content="Bryce">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#e0e0e0">
  <meta name="msapplication-navbutton-color" content="#e0e0e0">
  <meta name="apple-mobile-web-app-status-bar-style" content="#e0e0e0">

  <link rel="icon" href="/img/b.ico">
  <link rel="stylesheet" href="/libs/twitter-bootstrap/css/bootstrap.min.css">
  <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/libs/jqueryui/jquery-ui.min.css">
  <link rel="stylesheet" href="/libs/jquery.tocify/stylesheets/jquery.tocify.min.css">
  <link rel="stylesheet" href="/css/main.css">

  <link rel="stylesheet" href="/css/iconfont.css">

  <script src="/libs/jquery/jquery.min.js"></script>
  <script src="/libs/jquery-cookie/jquery.cookie-1.4.1.min.js"></script>
  <script src="/libs/twitter-bootstrap/js/bootstrap.min.js"></script>
  <script src="/libs/jqueryui/jquery-ui.min.js"></script>
  <script src="/libs/jquery.tocify/javascripts/jquery.tocify.min.js"></script>
</head>
<body>


<div class="wrap">
  <nav class="page-navigation">
    <div class="nav-container">
        <div class="page-header-logo">
            <h1 class="prince-log">
                <a href="/" class="home-link">Bryce&#39;s Log</a>
            </h1>
        </div>
        <button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <ul class="collapse navbar-collapse main-nav-items">
            <li class="menu-item">
                <a href="/" target="_self">主页</a>
            </li>
            <li class="menu-item">
                <a href="/categories/%e6%8a%80%e6%9c%af/" target="_self">技术</a>
            </li>
            <li class="menu-item">
                <a href="/categories/%e7%94%9f%e6%b4%bb/" target="_self">生活</a>
            </li>
            <li class="menu-item">
                <a href="/categories/%e9%9a%8f%e7%ac%94/" target="_self">随笔</a>
            </li>
            <li class="menu-item">
                <a href="/about/" target="_self">关于</a>
            </li><li class="menu-item">
                <div id="search-button">
                    <a class="site-page social-icon search" data-pjax-state="external">
                        <i class="iconfont icon-sousuo5"></i> 
                    </a>
                </div>
            </li>
            
        </ul>
    </div>
</nav>
  <main class="hiruko-container"><div class="post">
  <article class="post-block">
    <h1 class="post-title">Git：原理、使用与实践</h1>
    <div class="post-info">Dec 1 2022</div>
    <div class="post-entry" id="blog-content">
      
      
      <p>本文从Git的底层出发，深入探索Git的底层数据对象、数据存储优化、数据远程传输和历史记录维护，以此理解Git的版本控制机制，在探索原理的基础上总结Git的常用命令和最佳工作实践。</p>
<h2 id="简介">简介</h2>
<p>Git是一个<strong>分布式版本控制</strong>系统。</p>
<ul>
<li>版本控制：记录文件内容变更，支持查阅特定版本修订情况</li>
<li>分布式：每个本地客户端都保存数据仓库的<strong>完整镜像</strong></li>
</ul>
<p>Linux缔造者Linus Torvalds在2005年开发出Git用于管理维护Linux内核开源项目，Git的目标是：</p>
<ul>
<li>速度</li>
<li>简单的设计</li>
<li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li>
<li>完全分布式</li>
<li>高效管理类似Linux内核一样的超大规模项目</li>
</ul>
<p>从根本上讲，Git是一种基于快照的内容寻址文件系统/键值对数据库，并在此基础上提供一些版本控制的用户接口。</p>
<h2 id="概念">概念</h2>
<ul>
<li>快照
<ul>
<li>Git通过快照（提交时的文件全部内容）记录修改，而不是基本文件+增量更新</li>
</ul>
</li>
<li>校验和
<ul>
<li>Git在存储任何数据时都会通过SHA-1算法计算校验和，以此作为数据的唯一标识</li>
<li>将Git视为键值对存储系统时，键即为：SHA-1校验和，值即为：数据</li>
</ul>
</li>
<li>文件状态与工作区域
<ul>
<li>Git所管理的文件可能处于三种状态之一：
<ul>
<li>已修改 Modified：修改文件，但未保存到数据库</li>
<li>已暂存 Staged：对已修改文件的当前版本进行暂存，从而支持保存到数据库</li>
<li>已提交 Committed：文件已保存到数据库</li>
</ul>
</li>
<li>每种状态对应Git的一种工作区域
<ul>
<li>工作目录 Working Directory
<ul>
<li>工作目录是对项目的某个版本独立提取出来的内容，使用者直接面向工作目录进行使用和更改</li>
</ul>
</li>
<li>暂存区域 Staging Area / Index
<ul>
<li>暂存区域保存了将要提交的文件信息</li>
</ul>
</li>
<li>Git仓库 .git directory
<ul>
<li>Git仓库用来保存项目的元数据和对象数据库，包含项目的所有版本的数据</li>
</ul>
</li>
</ul>
</li>
<li>基本的Git工作流程是
<ul>
<li>在工作目录中修改文件</li>
<li>暂存文件，将文件快照放入暂存区域（概念上，实际上暂存区域存放文件索引/指针）</li>
<li>提交更新，找到暂存区域文件，将快照永久存储到Git仓库</li>
</ul>
</li>
<li>工作目录中可以存在不由Git管理的文件，即：未跟踪Untracked的文件，可以将此类文件名称pattern放到<code>.gitignore</code>文件中，用来显式告知Git：此类文件不纳入版本控制也无需显式指出Untracked状态</li>
</ul>
</li>
<li>分支
<ul>
<li>分支代表一条独立的开发线，通过分支可以使开发者从开发主线分离开来，在不影响主线的同时继续开发和提交</li>
<li>Git中分支实际上是指向更改快照的指针</li>
</ul>
</li>
<li>标签
<ul>
<li>Git可以给历史中的某一个提交打上标签，用来指明这个提交版本的功能/特性</li>
<li>Git中主要有两种标签
<ul>
<li>轻量标签lightweight
<ul>
<li>只是一个特定提交的引用</li>
</ul>
</li>
<li>附注标签annotated
<ul>
<li>存储到Git仓库的一个完整对象，包含打标签者的名字、邮件、日期时间和标签信息， 并可使用GNU Privacy Guard（GPG）签名与验证</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>远程仓库
<ul>
<li>远程仓库是指项目托管在Internet或其他网络中的项目的版本库</li>
</ul>
</li>
<li>author&amp;committer</li>
</ul>
<h2 id="原理">原理</h2>
<p>Git本质是一个内容寻址文件系统，其核心部分是一个键值对数据库，Git使用文件的SHA-1哈希值（160bit/40hex）作为key，文件快照作为value，提交、分支、标签等都是对key的组合和引用。</p>
<h3 id="git对象">Git对象</h3>
<ul>
<li>
<p>数据对象 Blob Object：<strong>保存文件内容</strong></p>
<ul>
<li>blob对象类似UNIX中的inode，存储数据内容，即项目中的文件的内容</li>
<li>每当将文件加入暂存区时，Git会将文件快照（当前全部数据）保存到一个blob对象（逻辑上，实际可能会存在pack优化）</li>
<li>blob对象的键是文件内容的SHA-1哈希值，值为文件内容，如果两个文件的内容相同则在Git中也仅会保存一个blob对象</li>
<li>blob对象物理上保存在<code>.git/objects/</code>目录中，具体保存路径是：<code>.git/objects/ab/x...y</code>，其中<code>ab</code>是blob键（即SHA-1哈希值）的前两个hex字符，<code>x...y</code>是blob键的剩余38个hex字符，保存格式为二进制（zlib压缩）</li>
<li>可通过<code>git hash-object &lt;file&gt;</code>命令根据传入的文件内容获取其blob对象的键（即文件内容的SHA-1哈希值），<code>-w</code>选项可同时保存此blob对象到Git仓库</li>
<li>可通过<code>git cat-file -p &lt;sha1&gt;</code>命令查看此对象的内容</li>
<li>可通过<code>git cat-file -t &lt;sha1&gt;</code>命令查看此对象的类型（blob/tree/commit）</li>
</ul>
</li>
<li>
<p>树对象 Tree Object：<strong>保存文件名和文件组织层次</strong></p>
<ul>
<li>
<p>tree对象类似UNIX中的目录，将多个文件和子目录组织起来，其包含了一条或多条tree entry，每个entry含有一个指向blob对象或者tree对象的SHA-1指针，以及相应的模式、类型、文件名信息</p>
<p>
<img style="display:none;" src="" alt="一个tree对象示例" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7ee8e2f57e3789bfad41ebcb95250a51ede507d0f154df0c6d4d9b4fb7da7b230e 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c018341352715c5f31fdb917df5c31ae3468bfeecf107bb0cf78ad40893f00b485359" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>每当暂存区变化后，Git根据当前时刻暂存区的状态创建并保存一个相应的tree对象；暂存区中实际上仅会保存文件，不会保存目录，Git会根据文件的层次结构自动生成相应层次的tree对象</p>
</li>
<li>
<p>tree对象和blob对象相同，物理上保存在<code>.git/objects/</code>目录中，具体保存路径是：<code>.git/objects/ab/x...y</code>，其中<code>ab</code>是tree键（即SHA-1哈希值）的前两个hex字符，<code>x...y</code>是tree键的剩余38个hex字符，保存格式为二进制</p>
</li>
</ul>
</li>
<li>
<p>提交对象 Commit Object：<strong>保存版本的时序关系和版本信息</strong></p>
<ul>
<li>
<p>commit对象在一个tree对象的基础上保存了一次提交的时间、作者、提交信息以及本提交的父提交对象（if exists）</p>
<p>
<img style="display:none;" src="" alt="一个commit对象示例" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e15dc6ae29bf3fe50707a1050629e0dc012d82d2fa923c271372262e30814e1df 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c018350e09b62276d1444ba4293a5c9d856d7e51066fb8f0e8c677798a4e1bdaed122" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>commit对象的格式是：</p>
<ul>
<li>一个顶层tree对象的SHA-1哈希值，代表当前项目快照</li>
<li>父提交对象的SHA-1哈希值</li>
<li>作者信息：name email 时间戳</li>
<li>提交者信息：name email 时间戳</li>
<li>留空一行</li>
<li>提交信息</li>
</ul>
</li>
<li>
<p>每当执行提交操作时，Git会在当前暂存区tree对象的基础上生成一个新的commit对象</p>
</li>
<li>
<p>commit对象和blob对象相同，物理上保存在<code>.git/objects/</code>目录中，具体保存路径是：<code>.git/objects/ab/x...y</code>，其中<code>ab</code>是tree键（即SHA-1哈希值）的前两个hex字符，<code>x...y</code>是tree键的剩余38个hex字符，保存格式为二进制</p>
</li>
</ul>
</li>
<li>
<p>标签对象 Tag Object</p>
<ul>
<li>tag对象类似一个commit对象，包含标签创建者信息、日期、标签注释信息以及一个指向commit对象的SHA-1哈希值</li>
<li>当创建附注标签时，会产生一个tag对象</li>
<li>tag对象和blob对象相同，物理上保存在<code>.git/objects/</code>目录中，具体保存路径是：<code>.git/objects/ab/x...y</code>，其中<code>ab</code>是tree键（即SHA-1哈希值）的前两个hex字符，<code>x...y</code>是tree键的剩余38个hex字符，保存格式为二进制</li>
</ul>
</li>
<li>
<p>通用对象存储格式</p>
<ul>
<li>所有Git对象都遵循如下格式进行组织
<ul>
<li>对象类型+空格+数据载荷长度+零字节+数据载荷</li>
</ul>
</li>
<li>Git将此格式数据进行SHA-1哈希，得到对象的key</li>
<li>最后，Git将此格式数据进行zlib压缩后保存到磁盘的某个文件，路径和文件名根据SHA-1哈希值生成</li>
</ul>
</li>
</ul>
<h3 id="git引用">Git引用</h3>
<ul>
<li>通过SHA-1哈希值可以唯一定位到任一类型的Git对象；为了使用方便可以将SHA-1哈希值保存在特定的文件中，并给文件起一个简单的名字，以此来最终定位到Git对象，此类文件即为Git引用 references/refs，物理上保存在 <code>.git/refs/</code>目录中</li>
<li>在Git中，引用包括
<ul>
<li>分支
<ul>
<li>一个指向某一系列提交对象之首的引用，物理上保存在 <code>.git/refs/heads/</code>目录</li>
<li>例如：master分支的引用路径为 <code>.git/refs/heads/master</code>文件，内容是<code>x...x</code>，即此分支最新提交的SHA-1哈希值</li>
<li>可通过底层命令：<code>git update-ref refs/heads/&lt;branch&gt; &lt;sha1&gt;</code>来创建一个指向sha1的分支<code>branch</code></li>
</ul>
</li>
<li>标签
<ul>
<li>一个指向某个提交对象或某个标签对象的引用，物理上保存在 <code>.git/refs/tags/</code>目录</li>
<li>标签引用的格式/底层创建同分支</li>
</ul>
</li>
<li>HEAD
<ul>
<li>HEAD文件（路径是 <code>.git/HEAD</code>）是一个符号引用symbolic reference，指向目前所在的分支</li>
<li>具体而言，HEAD文件的内容类似：<code>ref: refs/heads/master</code>，即指向当前所处的分支/标签的引用</li>
<li>当执行<code>commit</code>命令时，Git会创建一个提交对象，并使用HEAD指向的引用所指向的SHA-1哈希值设置此提交对象的父提交哈希值，同时将此提交对象的哈希值更新到HEAD所指向的引用文件</li>
<li>可通过 <code>git symbolic-ref HEAD refs/heads/test</code>来更新HEAD引用</li>
</ul>
</li>
<li>远程引用
<ul>
<li>当添加远程版本库并进行push操作后，Git会记录下push的远程分支的引用</li>
<li>具体路径是： <code>.git/refs/remotes/&lt;remote&gt;/&lt;branch&gt;</code></li>
<li>远程引用类似一个分支引用，但是远程引用只能通过push和pull命令进行更新，不能通过本地的commit命令进行更新，因此，即使可以checkout到某个远程分支引用，但HEAD引用也不会指向此远程引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="git优化">Git优化</h3>
<p>正常情况下，每次文件发生变更时Git都会对文件完整快照生成一个独立的blob对象</p>
<ul>
<li>从时间效率上看，每个变更单独快照的机制可以快速的定位到某次提交的内容，而不必在base的基础上沿提交链路依次叠加</li>
<li>从空间效率上看，由于很多情况下每次变更规模都远小于不变规模，因此单独快照的机制会重复存储很多相同数据，造成空间的浪费</li>
</ul>
<p>基于此，Git使用pack的方式节省空间提高效率</p>
<ul>
<li>
<p>loose对象：单独快照存储的Git对象</p>
</li>
<li>
<p>pack对象：通过pack的方式将不同Git对象的相同部分仅存储一次</p>
</li>
<li>
<p>pack机制将loose对象进行打包，生成一个pack文件和一个pack索引</p>
<ul>
<li>pack文件：存储不同loose对象的非重复部分，对于重复部分，剩余对象可以通过offset+size的机制进行引用，而不必重复存储全部内容</li>
<li>pack索引：记录每个Git对象的SHA-1哈希值、Git对象类型、大小、在pack文件中的offset和size</li>
<li>一般情况下，最新版本完整保存全部数据内容，而历史版本通过offset+size的方式保存重复部分，因为大部分情况下都需要快速访问文件的最新版本</li>
</ul>
</li>
<li>
<p>pack文件和索引物理上存储在 <code>.git/objects/pack/</code>目录中</p>
</li>
<li>
<p>进行pack的时机</p>
<ul>
<li>版本库中有很多loose对象时，一般7000+</li>
<li>版本库中有很多pack对象时，一般50+</li>
<li>手动执行<code>git gc</code>命令时</li>
<li>向远程服务器执行推送时</li>
</ul>
</li>
<li>
<p>可通过<code>git verify-pack -v &lt;path-to-pack.idx&gt;</code>的方式展示并验证pack索引内容</p>
</li>
</ul>
<p><code>git gc</code>命令是Git用来维护仓库，优化存取效率的命令。</p>
<ul>
<li><code>gc</code>会将loose对象合并到pack</li>
<li><code>gc</code>会将多个pack对象合并到一个pack</li>
<li><code>gc</code>会将多个引用打包到单独的文件，即将 <code>.git/refs/</code>目录下的文件打包到 <code>.git/packed-refs</code>文件以提高访问效率
<ul>
<li>当更新引用时，Git会在<code>.git/refs/</code>目录生成新的引用文件，也不会修改和更新pack文件，因此在查找引用时，Git会首先查找<code>.git/refs/</code>目录，然后查找pack文件</li>
</ul>
</li>
<li><code>gc</code>会移除与任何提交都不相关的陈旧对象
<ul>
<li><code>gc</code>内部调用 <code>git reflog expire</code>命令，默认将超过90天的reflog entry删除，同时默认将超过30天的从对应引用tip提交不可达的reflog entry删除</li>
<li><code>gc</code>内部调用<code>prune</code>命令，此命令会将同时满足两个条件的对象彻底删除
<ul>
<li>寿命限制：对象必须创建了足够长的时间（默认配置2周）</li>
<li>不可达限制：不能通过Git仓库的任意对象访问到此对象
<ul>
<li>任意对象包括普通Git对象、引用、reflog等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="git远程引用">Git远程引用</h3>
<p>远程引用是指对远程仓库中分支/标签的引用，物理上存储在 <code>.git/refs/remotes/</code>目录中。</p>
<ul>
<li>
<p>当添加远程版本库后，Git会在 <code>.git/config</code>配置文件中添加该远程版本库的配置：名称、URL、用于fetch和push操作的引用规则refspec</p>
<p>
<img style="display:none;" src="" alt="image-20221121161741941" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e199aa258a91316e487dfdb80c7d0d15b16902007a7e7a2ed80c31c2a4cfd7a56 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183d881d8d57213233ec0f0a39698c95c391bf04228b5151316e25647b398a81ef4" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>引用规则的格式为： <code>[+]&lt;src&gt;:&lt;dst&gt;</code></p>
<ul>
<li><code>+</code>：即使在不能fast-forward的情况下也要强制更新引用</li>
<li><code>src</code>：源引用</li>
<li><code>dst</code>：目的引用</li>
</ul>
</li>
<li>
<p>可通过修改refspec的形式，自定义远程分支的位置、远程分支拉取到本地分支的位置、拉取哪些远程分支、推送哪些分支到远程分支；也可以通过<code>git push/fetch origin &lt;src&gt;:&lt;dst&gt;</code>的形式手动指定本次f/p操作</p>
</li>
<li>
<p>可将<code>src</code>留空以删除远程版本库的<code>dst</code></p>
</li>
</ul>
<h3 id="git传输">Git传输</h3>
<p>Git主要通过dumb协议和smart协议在本地仓库和远程仓库间传输数据。</p>
<p>dumb协议简单，但效率低，而且不能从客户端向服务端推送数据。</p>
<p>smart协议更为高效，支持推送和获取，但需要在Git服务端运行进程进行协助和交互。</p>
<h4 id="dumb协议">dumb协议</h4>
<p>dumb协议将Git项目视为简单的键值数据库，通过HTTP请求以此获取，此过程无需Git本身的协助</p>
<p>dumb协议的具体过程是</p>
<ul>
<li>
<p>Git服务端通过<code>git update-server-info</code>命令在 <code>.git/info/refs/</code>目录中生成<code>refs</code>文件，其中包含Git仓库的所有引用（分支+标签）以及SHA-1哈希值</p>
<p>
<img style="display:none;" src="" alt="image-20221121204515176" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7eb841cbdac9d5cb92d0f3e58eaf443774f50c175e30da2aa45da008469893ad59 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c018329c5ea3c43ca23698d08f510141ea14f14632c5a9c6a522165bb322dcfe810b6" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>客户端首先通过GET请求获取<code>refs</code>文件，然后依次根据SHA-1哈希值获取loose对象</p>
</li>
<li>
<p>对于获取的loose对象，根据其中的SHA-1哈希值获取其他Git对象</p>
</li>
<li>
<p>当无法获取loose对象时（返回404响应），请求pack目录下的索引文件，然后检查SHA-1哈希值是否在索引文件中，然后继续请求pack文件</p>
</li>
<li>
<p>重复上述过程，直到链路上的所有SHA-1都获取了对应的Git对象</p>
</li>
</ul>
<h4 id="smart协议">smart协议</h4>
<p>smart协议需要在Git服务端运行进程和客户端进行交互，通过两组进程传输数据，smart协议仅传输需要交换的数据，而无需传输全部内容。</p>
<h5 id="上传数据">上传数据</h5>
<p>上传数据需要运行在客户端上的<code>send-pack</code>进程连接到服务端运行的<code>receive-pack</code>进程。</p>
<ul>
<li>
<p>SSH协议传输</p>
<ul>
<li>
<p>客户端运行<code>send-pack</code>进程，通过SSH连接服务器，然后通过SSH发送命令字符串以使服务端执行命令</p>
<p>
<img style="display:none;" src="" alt="image-20221121213647976" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7ef87aa3fd1ee8ff17fdc41702667957214ab5706985cfb752f6b647c44933c770 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183f4901976d3a161195de02f19d301983196c5a609c29214f400cf1d6495f1d3e2" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p><code>git-receive-pack</code>命令会为服务端拥有的每一个引用（分支/标签）发送一行响应</p>
<ul>
<li>响应格式：前四字节代表本行长度，然后是SHA-1哈希值，然后是引用名称</li>
<li>对于第一行，还会在原基础上包含服务端能力（如report-status等，以及客户端识别码）</li>
<li>对于最后一行，为0000</li>
</ul>
</li>
<li>
<p>此时客户端已经明确了服务端的状态，此时<code>send-pack</code>进程会判断哪些提交对象是客户端具有但服务端没有的</p>
<ul>
<li>如果服务端的引用的SHA-1值在本地不存在，则说明无法通过fast-forward的方式推送到远程分支</li>
<li>如果服务端的引用的SHA-1值在本地存在，则可以定位出在远程引用之后进行的所有本地提交</li>
</ul>
</li>
<li>
<p>接下来客户端会为本次推送将会更新的各个引用向服务端发送一行请求</p>
<p>
<img style="display:none;" src="" alt="image-20221121221831118" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e47749770a7de280843dfd9ef3d2a4920d5c6db6b4905fdb42eb5ca38e44b6d08 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183d0f7372ccff918b6fb5a2366acefb18ead5e8f6415a5f67ebf1dbfbefcdaf3cf" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
<ul>
<li>请求格式：前四字节代表本行长度，然后是旧SHA-1值，然后是新SHA-1值，然后是要更新的引用名称</li>
<li>新增引用时，旧SHA-1值为0；删除引用时，新SHA-1值为0</li>
<li>对于第一行，还会在原基础上增加客户端能力</li>
<li>对于最后一行，为0000</li>
</ul>
</li>
<li>
<p>然后，客户端会发送一个pack文件，包含了所有服务端还没有的Git对象</p>
</li>
<li>
<p>最后，服务端会以成功或失败响应</p>
<p>
<img style="display:none;" src="" alt="image-20221121222324803" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e5ef065e2c00f6dd8dcc90a66dd0b52714b8491e69405c1f4eed92e70650a6d13 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c018355b454b4e77ae2a8d9739b3d010ce26abf0c8d6e774ac07eee431f8881f89652" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
</ul>
</li>
<li>
<p>HTTP/HTTPS协议传输</p>
<ul>
<li>
<p>首先，客户端通过GET请求传递命令，并接受响应（内容与格式同上）</p>
<p>
<img style="display:none;" src="" alt="image-20221121222512822" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e76e858f6e8c1d4bd8f07ecd2605f9421a2a76471e2957eba9e980d86fcf06507 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183514bc8e7b3a963ce16df693e97a51506513ff0749b938072dbdf5bbc1518f9df" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>然后客户端发起请求，上传pack，并接收响应（内容与格式同上）</p>
<p>
<img style="display:none;" src="" alt="image-20221121222645095" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7ef4e0b205c066bb869100578b8d93e4989a56c254f27f9d112cbb9082f4406f93 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c01832bd14399792111f94333902eafc926fe2193415741887b6c4f609c2f8d0792fd" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
</ul>
</li>
</ul>
<h5 id="下载数据">下载数据</h5>
<p>下载数据需要客户端的<code>fetch-pack</code>进程连接到服务端的<code>upload-pack</code>进程</p>
<ul>
<li>
<p>SSH协议</p>
<ul>
<li>
<p>客户端运行<code>fetch-pack</code>进程，通过SSH向服务端发送命令调用<code>upload-pack</code>进程</p>
<p>
<img style="display:none;" src="" alt="image-20221121223123043" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e2ff9177180e4e2afa1da6f6c44207162ea2a8a190313f5f32e06796695fcd1a8 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183164972340f282beec6a22769960d5d2f56f1302b6e87ce7ad120362b5dae2950" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>服务端会为拥有的每个引用发送一行响应，响应格式同上</p>
<ul>
<li>服务端还会为HEAD引用发送响应，因此当客户端执行clone时会确认工作目录对应的提交</li>
</ul>
</li>
<li>
<p>客户端会查看自己拥有的对象，并通过want响应需要的对象的SHA-1值，通过have响应已拥有的SHA-1值，通过done结束请求</p>
<p>
<img style="display:none;" src="" alt="image-20221121223633248" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e9ded71fca20b7214d7745fbfe13fc664c5e7e9a5c743622506209d16ed3794d1 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183bdd154b1d55fdc79850dfb4a1695f761f28fec3fbb45121dffc3f73c8e2767b7" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>最后，服务端可以发送pack文件，包含客户端需要的所有Git对象</p>
</li>
</ul>
</li>
<li>
<p>HTTP/HTTPS协议</p>
<ul>
<li>
<p>HTTP/HTTPS协议也涉及两个请求响应</p>
<p>
<img style="display:none;" src="" alt="image-20221121223753068" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e2d4ecfd471105c322c3095fb4688b9353b726a8091237a4e69eea36261eb17e5 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183f6305c7af5d4fab79cd7597c906dd146f25ad15d9a544d2a04433faa3f4b5804" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
<p>
<img style="display:none;" src="" alt="image-20221121223807145" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e27f40e64297e51a861a33409dc74c48a8a1371608cd67d7b90a9db0ca119ed9a 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183de60cd9b21c8a64ee000211ac39e2f9637a9f7e5989fb982a9c2f88834d5e9b4" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
<li>
<p>请求响应的内容格式同上</p>
</li>
</ul>
</li>
</ul>
<h3 id="git数据维护">Git数据维护</h3>
<h4 id="数据恢复">数据恢复</h4>
<p>在某些情况下，可能会失去某些提交的引用：如reset重置分支到之前某一提交，此时后续提交对象（包括包含的tree和blob对象）仍然存在于<code>./git</code>仓库中，但是无法通过引用定位到他们的SHA-1值，Git提供了reflog机制（同时也是命令）和fsck命令来展示历史提交对象的SHA-1值。</p>
<p>reflog机制在每次更改引用（分支+标签+HEAD）时都会记录此时引用的SHA-1哈希值，由此可以使我们定位到之前指向的Git对象。</p>
<ul>
<li>
<p>Git会把引用的变更日志物理上保存在 <code>.git/logs/</code>目录中</p>
<p>
<img style="display:none;" src="" alt="image-20221121231848261" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7eb27a7d0d1b1658910ffefc45461935ca702b63305d9cc4c164fee4e08e597fb6 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183712af3b38e72abd90a3d68b4091c02256b959825c003e8db45095216698bef52" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
</li>
</ul>
<p><code>git fsck</code>命令会分析Git数据库的完整性，通过<code>--full</code>选项会显示出所有没有被其他对象指向的对象，由此可以找到丢失对象的SHA-1哈希值。</p>
<p>
<img style="display:none;" src="" alt="image-20221121232317348" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e7d77b8be8c2a45f1705eb70b7b7e8b39589e16d5e3bd8479365f4c429aa311a8 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c01837145c964d4591b5163349bc361c419bc91180f0e4900e56d9b4ef3a72d2063a4" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
<p>在找到提交的SHA-1值后，可通过在此提交上建立分支的方式重新将此系列提交添加到Git控制体系中。</p>
<h4 id="数据移除">数据移除</h4>
<p>作为一个分布式版本控制系统，版本控制使得Git保存所有的完整的历史提交和文件，分布式则使得Git执行clone操作时也会下载整个项目的全部历史。在特殊情况下，如果误提交了一个大文件，那么即使后续提交中将其移除，那么每次clone操作仍会下载这个误提交的大文件，造成不必要的资源浪费，Git提供了一种修改历史提交的机制以删除历史提交中的某个对象。</p>
<blockquote>
<p>注意：此操作对提交历史的修改是破坏性的，它会从包含该大文件的最早的树对象开始重写每一次提交，如果其他committer已经基于原始提交进行开发和提交，则需要他们将自己的提交变基rebase到修改历史后的新提交中。</p>
</blockquote>
<p>一些查看Git仓库占用大小的命令</p>
<ul>
<li><code>git gc</code>命令以进行pack</li>
<li><code>git count-objects -v</code>命令得到各部分的详细大小</li>
</ul>
<p>数据移除的具体步骤是</p>
<ul>
<li>找到大文件
<ul>
<li>执行<code>git gc</code> 后再执行<code>git verify-check -v</code>命令，然后根据输出的第三列（文件大小）进行排序从而找到大文件的SHA-1值</li>
<li>执行<code>git rev-list --objects --all</code>命令会列出所有提交的SHA-1、blob对象的SHA-1和其关联的文件路径，从中根据之前确认的SHA-1值找到文件名称</li>
</ul>
</li>
<li>找到添加大文件的提交
<ul>
<li>执行<code>git log --oneline --branches -- &lt;filename&gt;</code>以找到所有改动文件的提交</li>
</ul>
</li>
<li>修改此提交之后的所有提交来从历史中完全移除文件
<ul>
<li>执行<code>git filter-branch --index-filter 'git rm --ignore-unmatch --cached &lt;filename&gt;' -- &lt;commit-sha1&gt;^..</code>命令</li>
<li><code>filter-branch</code>命令用来重写Git分支，并链式的修改所有提交</li>
<li><code>--index-filter &lt;command&gt;</code>选项将提交checkout到index暂存区后执行command命令然后提交，不会将提交checkout到工作目录（相当于仅checkout SHA-1值而不checkout具体数据），因此command也只能修改暂存区中的SHA-1值而不能修改具体数据</li>
<li><code>-- &lt;commit&gt;^..</code>选项会从commit开始修改而非从最初提交开始</li>
</ul>
</li>
<li>移除任何包含指向旧提交的指针的文件
<ul>
<li><code>git filter-branch</code>命令会在 <code>.git/refs/original/</code>目录下记录原始的引用SHA-1值</li>
<li>reflog机制也会在 <code>.git/logs/</code>目录中记录原始SHA-1值</li>
<li>因此，需要删除这两个文件，以移除任何包含指向旧提交的指针的文件</li>
</ul>
</li>
<li>重新打包
<ul>
<li>执行<code>git gc</code>命令，此时pack文件不会再包含移除的大文件</li>
<li>注意：如果大文件的创建时间小于配置时间，则大文件仍然会以loose对象的形式存在于本地仓库中，但不会影响和参与到push/pull操作（详见上述<code>git gc</code>命令）</li>
</ul>
</li>
<li>可选：在本地仓库彻底删除
<ul>
<li>通过<code>git prune --expire now</code>命令完全移除此大文件，即所有引用不可达的孤儿对象</li>
</ul>
</li>
</ul>
<h3 id="git-diff">Git Diff</h3>
<p>Git通过diff展示某次提交/暂存做了哪些改动，diff也是merge操作的基础。</p>
<p><code>git diff</code>产生的输出格式如下：</p>
<p>
<img style="display:none;" src="" alt="image-20221126121545848" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e77a601fcb547b4b3cc67b094646e03d8efe31337b4daa98eb632292e601083f6 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183f8eef01cadc0f379c4fa9386a8082ac7cfa8a24a4652956c19555e1f8f378638" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
<ul>
<li><code>diff --git a/txt b/txt</code>表明实际调用的命令</li>
<li><code>index &lt;old&gt;..&lt;new&gt; mode</code>表明比较的两个文件的sha-1值和文件模式</li>
<li><code>--- &lt;old&gt;</code>表示旧文件</li>
<li><code>--- &lt;new&gt;</code>表示新文件</li>
<li><code>@@ -3,7 +3,7</code>表明旧文件发生diff的起始行,行数和新文件发生diff的起始行,行数</li>
<li>以下即为具体比较结果，-表示移除旧文件此行，+表示增加新文件此行</li>
</ul>
<p>Git中diff支持两种算法Myers算法和Patience算法，默认采用Myers算法。</p>
<p>从算法角度，diff对应的模型是：对于两个文本A和B，允许两种操作：插入、删除，求出操作数量最少（即编辑距离最短）的A转为B的操作序列。</p>
<h4 id="myers算法">Myers算法</h4>
<p>Myers算法由 Eugene W.Myers 在 1986 年发表在 《 Algorithmica》 杂志上的一篇论文中提出，是一个能在大部分情况产生最短的直观的diff 的一个算法，最短指编辑距离最短，直观指删除插入由于插入删除，整块代码删除新增优于交叉删除新增。</p>
<p>算法内容可参考：https://cloud.tencent.com/developer/article/1724029</p>
<h4 id="patience算法">Patience算法</h4>
<p>Patience算法的作者是BitTorrent的作者Bram Cohen. 在他的博客上有一个简单的介绍( <a href="https://bramcohen.livejournal.com/73318.html">https://bramcohen.livejournal.com/73318.html</a> , <a href="https://alfedenzo.livejournal.com/170301.html">https://alfedenzo.livejournal.com/170301.html</a> ).</p>
<p>patience diff实际上不算是一种算法, 而是一种在对比两个文本时如何在应用diff算法(例如Myers)前, 将文本分为合理的小文本的手段. 做这种预先处理的原因是, Myers经常将一些无意义的行匹配起来, 例如空行和括号, 这会导致一些恼人的匹配结果以及导致合并冲突的结果. Patience diff 的改进是: 对两个文本都进行一次全扫描, 得到一组共有的, 在各自文本里都只出现了一次的行, 这将助于得到更有意义而不是生硬的内容划分。</p>
<h3 id="git-mergerebaserevert">Git Merge/Rebase/Revert</h3>
<p>合并是非线性工作流的基础操作，其核心是将不同分支的变更集成在一起。Git中主要有两种操作进行集成分支，<code>merge</code>和<code>rebase</code>。</p>
<h4 id="fast-forward">Fast-Forward</h4>
<p>当合并的两个分支存在线性亲缘关系时（即本分支是目标分支的祖先提交），从逻辑和实际角度，合并操作仅会将原分支指向目标分支，不产生任何比较、冲突情况。这种特殊情况的merge方式为快进fast-forward。</p>
<h4 id="three-way-merge">Three-Way Merge</h4>
<p>当合并的两个分支不存在线性亲缘关系时，合并策略是三路合并three-way merge。具体而言：</p>
<ul>
<li>three-way
<ul>
<li><code>base</code>：两个分支的最近共同祖先提交的文件</li>
<li><code>ours</code>：当前分支的文件</li>
<li><code>theirs</code>：目标合并分支的文件</li>
</ul>
</li>
<li>LCS
<ul>
<li>在确定三路文件后，通过算法找出三路文件的LCS/最长公共子序列</li>
</ul>
</li>
<li>merge
<ul>
<li>三路文件根据LCS一一对应后
<ul>
<li>b/base和o/ours和t/theirs如果其中两者相同（包括两者都为空），则使用第三者作为输出</li>
<li>如果b和o和t都不相同，说明o和t修改了同样的区域，产生冲突</li>
</ul>
</li>
</ul>
</li>
<li>对于新增文件，通过文件名一一对应
<ul>
<li>如果b和o和t其中两者相同（包括两者不存在），则使用第三者作为输出</li>
<li>如果b和o和t都不相同，则产生冲突</li>
</ul>
</li>
</ul>
<h4 id="recursive-three-way-merge">Recursive Three-Way Merge</h4>
<p>在一些特殊场景下，两个合并分支的最近共同祖先非唯一：</p>
<p>
<img style="display:none;" src="" alt="image-20221126131906688" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e8a9b53d199ade9fbd3f1cac1ae4f131bee20e2255621eda69fbbeee184e3bfe9 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c0183725f4722f4c72cbef419b78d36d7bed87fa36d79b396fac1056762f9a5ba62e9" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</p>
<p><strong>recursive three-way merge</strong>算法会首先合并两个最近共同祖先到一个虚拟节点，然后选定虚拟节点为base分支进行三路合并，在合并两个最近共同祖先时，仍然采用<strong>recursive three-way merge</strong>算法，因此此算法称为<strong>recursive</strong>。</p>
<h4 id="multi-way-merge">Multi-Way Merge</h4>
<p>在合并多个分支时，三路归并算法会产生多个中间节点，造成提交记录拓扑的混乱，<strong>mutil-way merge</strong>会逐步采用三路归并算法，同时不在最终提交记录中保持中间节点。</p>
<h4 id="merge-strategy">Merge Strategy</h4>
<p><code>git merge -s &lt;strategy&gt;</code>可以选定strategy合并策略</p>
<ul>
<li><code>resolve</code>策略对应<strong>three-way merge</strong>算法，如果存在两个最近共同祖先时，<code>resolve</code>策略自动选择其中在它看来最优的一个作为base，同时不会检测文件重命名操作，即如果两个分支分别重命名源文件到不同名称文件时，<code>resolve</code>策略会视为两个分支同时删除源文件，分别新增新的不同的文件，因此不会产生合并冲突</li>
<li><code>recursive</code>策略对应<strong>recursive three-way merge</strong>算法，同时<code>recursive</code>策略会检测文件重命名操作，因此如果两个分支同时重命名源文件到不同名称文件时，<code>recursive</code>策略会产生合并冲突</li>
<li><code>ort</code>策略和<code>recursive</code>策略采用的算法和对应输出相同，但是<code>ort</code>策略重构了<code>recursive</code>策略的代码，效率更高、速度更快</li>
<li><code>octopus</code>策略对应<strong>multi-way merge</strong>算法，当<code>merge</code>命令同时合并多个分支时使用此策略</li>
</ul>
<h4 id="git-apply">Git Apply</h4>
<p><strong>apply</strong>机制是合并不同分支变更的另一种实现方式。本质上，<strong>apply</strong>是指对另一分支在本分支之外的所有提交产生一个补丁/patch，然后依次将每个patch应用到本分支。</p>
<p>patch中包含了变更的上下文和变更本身，git通过<strong>patch context</strong>（变更上下文）定位到变更位置，然后应用具体变更，因此会存在一些特殊case导致变更应用到错误的位置（比如根据patch上下文可以定位到多个位置，又比如当前分支新增内容也符合patch上下文）</p>
<h4 id="git-rebase">Git Rebase</h4>
<p><code>git rebase</code>命令是Git向用户提供的合并不同变更的另一个顶层命令。</p>
<p>从逻辑上讲，<code>rebase</code>命令将分支A相对于分支B的所有提交保存成patch文件，然后将patch文件依次应用到分支B。因此从提交记录拓扑图上，<code>rebase</code>命令在分支B上新进行了多个patch提交，然后将分支A引用指向最终提交，是一个线性的拓扑图。</p>
<p>从实现上讲，<code>rebase</code>命令实际存在两种实现方式</p>
<ul>
<li><code>merge</code>方式：对于分支A相对于分支B的每个提交C，执行一次merge操作
<ul>
<li><code>base</code>：<strong>提交C</strong>的<strong>直接父提交</strong>（<strong>注意：不是最近共同祖先提交</strong>）</li>
<li><code>ours</code>：分支B的顶层提交</li>
<li><code>theirs</code>：提交C</li>
<li>默认情况下，或者通过 <code>-i</code>选项指定时，都采用此方式</li>
<li>底层实现上，此方式相当于对每个提交C执行 <code>git cherry-pick C</code></li>
</ul>
</li>
<li><code>apply</code>方式：对于分支A相对于分支B的每个提交C，生成patch文件然后依次应用到分支B
<ul>
<li>通过 <code>--apply</code>选项可以指定此方式</li>
</ul>
</li>
</ul>
<p>注意：分支A相对于分支B的每个提交，即分支A中从分支AB的最近共同祖先开始的每个提交</p>
<p>注意：<code>git rebase</code>命令会忽略分支A中新增的merge提交，因为逻辑上已经新增了merge提交的每个变更，因此无需再次考虑merge提交。</p>
<ul>
<li>这种情况下，由于rebase实际上忽略了merge提交时可能的冲突解决变更，因此可能会出现通过<code>rebase</code>和<code>merge</code>命令合并分支时，<code>rebase</code>产生合并冲突，<code>merge</code>不产生合并冲突。</li>
</ul>
<h4 id="git-revert">Git Revert</h4>
<p><code>git cherry-pick</code>命令用来撤销某个提交所进行的变更，是<code>revert</code>命令的完全逆操作，逻辑上，<code>cherry-pick</code>对当前分支应用父提交到子提价的修改，<code>revert</code>对当前分支应用子提交到父提交的修改；实现上，<code>cherry-pick</code>和<code>revert</code>都采用<strong>recursive three-way merge</strong>算法，只不过两者的<code>base</code>和<code>theirs</code>相反。</p>
<p>对于<code>git revert</code>命令，对于当前分支A，待撤销提交C：</p>
<ul>
<li><code>base</code>：C</li>
<li><code>ours</code>：A</li>
<li><code>theirs</code>：C的直接父提交</li>
</ul>
<h3 id="git目录">Git目录</h3>
<p>每个由Git管理的项目都会有一个对应的<code>.git</code>隐藏目录用来保存Git存储和操作的所有对象（概念上包括项目的所有版本和暂存区），<code>.git</code>目录中包含如下文件</p>
<ul>
<li><code>HEAD</code>
<ul>
<li>指向当前所处的分支</li>
</ul>
</li>
<li><code>config</code>
<ul>
<li>保存项目特有的配置选项</li>
</ul>
</li>
<li><code>description</code>
<ul>
<li>项目描述信息，用于GitWeb程序使用</li>
</ul>
</li>
<li><code>COMMIT_EDITMSG</code>
<ul>
<li>保存最新一次提交的日志信息</li>
</ul>
</li>
<li><code>index</code>
<ul>
<li>暂存区，实际存储指向每个对象的指针（SHA-1值）</li>
<li>可用<code>git ls-files -s</code>命令查看暂存区的文件信息</li>
</ul>
</li>
<li><code>hooks/</code>
<ul>
<li>保存Git特定动作时触发的自定义脚本，分为客户端hook和服务器hook</li>
</ul>
</li>
<li><code>info/</code>
<ul>
<li>保存git仓库的一些额外本地信息，主要包括
<ul>
<li>exclude文件，作用与 <code>.gitignore</code>文件相同，但不会纳入Git版本控制（checkout时也不会变动），因此可用于只应用于本地的排除操作</li>
<li>attributes文件，作用与 <code>.gitattributes</code>文件相同
<ul>
<li>针对特定文件配置特定属性，用于单独定义文件属性/合并策略/diff等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>objects/</code>
<ul>
<li>保存所有的Git对象（blob+tree+commit+tag）</li>
<li>进行pack操作后，同时保存pack文件和索引</li>
</ul>
</li>
<li><code>refs/</code>
<ul>
<li>保存每个引用指向的Git对象的SHA-1值</li>
<li>内部包括<code>heads/</code>：保存本地分支；<code>tags/</code>：保存标签，<code>remotes/</code>：保存远程分支</li>
</ul>
</li>
<li><code>logs/</code>
<ul>
<li>保存每个引用（HEAD+分支）的变更记录，供<code>reflog</code>查询</li>
<li>内部结构类似于<code>refs/</code>目录</li>
</ul>
</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="选择符">选择符</h3>
<p>如前所述，Git本质上是一个键值对存储系统，可以通过SHA-1值定位对应的Git对象。Git也支持其他方式来指定某个或某些提交对象。</p>
<h4 id="单一提交">单一提交</h4>
<h5 id="sha-1">SHA-1</h5>
<ul>
<li>提交对象的完整SHA-1值</li>
<li>提交对象的简短SHA-1值，至少4位，同时保证无歧义</li>
<li>SHA-1是所有定位方法的本质</li>
</ul>
<h5 id="引用">引用</h5>
<ul>
<li>HEAD：定位当前所处的提交</li>
<li>分支：通过分支名称定位到分支的最新提交</li>
<li>标签：通过标签名定位到标签对应的提交</li>
</ul>
<h5 id="reflog">reflog</h5>
<ul>
<li><code>&lt;ref&gt;@{&lt;n&gt;}</code>
<ul>
<li>含义：引用ref倒数第n次所处的提交</li>
<li>实例：
<ul>
<li><code>HEAD@{0}</code>：等价于HEAD</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;ref&gt;@{time}</code>
<ul>
<li>含义：引用ref在时间time时指向的提交</li>
<li>实例：
<ul>
<li><code>HEAD@{1.hours.ago}</code>：1小时前HEAD所处的最后的提交</li>
</ul>
</li>
</ul>
</li>
<li>原理：通过reflog机制（<code>.git/logs/</code>）实现，因此一旦reflog删除/过期，则无法定位</li>
</ul>
<h5 id="祖先引用">祖先引用</h5>
<ul>
<li>定位符 <code>^</code>
<ul>
<li>格式：<code>&lt;selector&gt;^[&lt;n&gt;]</code></li>
<li>含义：选择符selector提交的第n父提交（均为selector的直接父提交）</li>
<li>注意：<code>^</code>的个数代表倒数第几代，n代表同一代中第几个父提交，可交替使用，n默认为1</li>
<li>实例：
<ul>
<li><code>HEAD^^</code>：HEAD的第一父提交的第一父提交</li>
<li><code>HEAD^2</code>：HEAD的第二父提交（当且仅当HEAD由merge得到，此选择符返回merge的第二个对象）</li>
<li><code>d9214^^^3</code>：提交<code>d9214</code>的第一父提交的第一父提交的第三父提交</li>
<li><code>master^1^^2</code>：master分支当前引用的第一父提交的第一父提交的第二父提交</li>
</ul>
</li>
</ul>
</li>
<li>定位符 <code>~</code>
<ul>
<li>格式：<code>&lt;selector&gt;~[&lt;n&gt;]</code></li>
<li>含义：选择符selector提交的倒数第n代的第一父提交，默认n为1，即直接父提交</li>
<li>实例：
<ul>
<li><code>HEAD~2</code>：HEAD的第一祖父提交，等价于：<code>HEAD~~</code>等价于 <code>HEAD^^</code></li>
</ul>
</li>
</ul>
</li>
<li>上述两个定位符可连用
<ul>
<li><code>HEAD~2^2</code>：HEAD的第一祖父提交的第二父提交（第二曾祖父提交）</li>
</ul>
</li>
<li>助记
<ul>
<li><code>~</code>：是近似线性连续的，表明一个直接的线性历史，因此数字表示代数</li>
<li><code>^</code>：是两条线合并到一点，表明分支合并结构，因此数字代表合并的同一代的第几个父提交</li>
</ul>
</li>
</ul>
<h4 id="提交区间">提交区间</h4>
<h5 id="双点">双点</h5>
<ul>
<li>格式：<code>&lt;refA&gt;..&lt;refB&gt;</code></li>
<li>含义：在<code>refB</code>分支而不在<code>refA</code>分支的全部提交</li>
<li>助记：<code>refA+..=refB</code>，因此表示在<code>refA</code>之外的提交</li>
<li>实例：<code>git log origin/master..HEAD</code>
<ul>
<li>列出当前分支中还未推送到远程master分支的所有提交</li>
</ul>
</li>
</ul>
<h5 id="排除">排除</h5>
<ul>
<li>格式：<code>&lt;refA&gt; &lt;refB&gt; ^&lt;refC&gt;</code></li>
<li>格式：<code>&lt;refA&gt; &lt;refB&gt; --not &lt;refC&gt;</code></li>
<li>含义：被<code>refA</code>或<code>refB</code>包含但不被<code>refC</code>包含的所有提交，可多个分支一起使用</li>
<li>实例：
<ul>
<li><code>refB ^refA</code>等价于 <code>refA..refB</code></li>
</ul>
</li>
</ul>
<h5 id="三点">三点</h5>
<ul>
<li>格式：<code>&lt;refA&gt;...&lt;refB&gt;</code></li>
<li>含义：被<code>refA</code>或<code>refB</code>包含但不被同时包含的所有提交</li>
<li>实例：<code>git log --left-right master...feat</code>
<ul>
<li>列出仅被<code>master</code>或仅被<code>feat</code>包含的提交</li>
<li><code>--left-right</code>选项使得仅被<code>master</code>包含的提交前带有小于号，否则带有大于号</li>
</ul>
</li>
</ul>
<h3 id="配置">配置</h3>
<h4 id="git-config">git config</h4>
<pre tabindex="0"><code>git config 
	[--system|---global|---local] 
	[--add|--get|--unset] 
	[--show-origin]
	[--list] 
	&lt;name&gt; [value]
</code></pre><ul>
<li>
<p>作用</p>
<ul>
<li>查看/变更Git配置</li>
</ul>
</li>
<li>
<p>选项</p>
<ul>
<li><code>--system</code>：配置面向系统内全部用户生效，即修改在 <code>/etc/.gitconfig or /etc/git/config</code>文件中</li>
<li><code>--global</code>：配置面向当前用户生效，即修改在 <code>~/.gitconfig or ~/git/config</code>文件中</li>
<li><code>--local</code>：配置面向此git项目生效，即修改在 <code>.git/config</code>文件，默认<code>local</code>，生效顺序优先级最高</li>
<li><code>--add</code>：在name配置的基础上新增value，不加<code>add</code>时默认情况下替换value</li>
<li><code>--get</code>：获取name的配置（首次匹配），<code>--get-all</code>获取全部作用域全部匹配的配置</li>
<li><code>--unset</code>：删除name的配置（首次匹配），<code>--unset-all</code>删除全部作用域全部匹配配置</li>
<li><code>--show-origin</code>：展示配置来源目录</li>
<li><code>--list</code>：获取全部配置，与配置范围联用</li>
<li><code>name</code>：配置名称，单独使用时展示name的值</li>
<li><code>value</code>：配置值</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li><code>git config --global user.name 'Bryce'</code>
<ul>
<li>配置用户名称（用于提交对象中的作者信息）</li>
</ul>
</li>
<li><code>git config --global alias.cmm 'commit -m'</code>
<ul>
<li>配置命令Git别名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="创建">创建</h3>
<h4 id="git-init">git init</h4>
<pre tabindex="0"><code>git init [name]
</code></pre><ul>
<li>作用
<ul>
<li>创建Git项目</li>
</ul>
</li>
<li>选项
<ul>
<li>默认情况下在当前目录创建git项目，即创建 <code>.git/</code>目录</li>
<li><code>name</code>：创建<code>name</code>目录为Git项目，即创建 <code>name/.git/</code>目录</li>
</ul>
</li>
</ul>
<h4 id="git-clone">git clone</h4>
<pre tabindex="0"><code>git clone 
	[--single-branch] 
	[--branch | -b] &lt;branchname&gt;
	&lt;url&gt; [name]
</code></pre><ul>
<li>作用
<ul>
<li>将url指向的远程仓库克隆到本地，默认情况下包括全部分支/标签/HEAD，同时在本地创建对应的远程分支引用，最后将HEAD引用的分支的提交checkout到工作目录。</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--single-branch</code>：只克隆单一分支的提交历史数据，默认情况下是远程仓库的HEAD指向的分支</li>
<li><code>-b</code>：克隆完成后checkout到branchname分支</li>
<li><code>url</code>：远程仓库url，可以是ssh协议或http(s)协议连接</li>
<li><code>name</code>：克隆至目录name</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git clone --single-branch -b dev git@github.com:U/blog.git </code></li>
</ul>
</li>
</ul>
<h3 id="变更">变更</h3>
<h4 id="git-add">git add</h4>
<pre tabindex="0"><code>git add
	[--dry-run | -n]
	[--update | -u]
	[--force | -f]
	[--all | -A]
	&lt;pathspec&gt;...
</code></pre><ul>
<li>作用
<ul>
<li>将工作目录中的变更（文件新增/修改/删除）添加到暂存区域/index</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-n</code>：不实际添加，只输出将要进行的操作</li>
<li><code>-u</code>：只处理已经track（已经存在于index）的文件</li>
<li><code>-f</code>：强制添加，跳过 <code>.gitignore</code>文件的限制</li>
<li><code>-A</code>：处理全部文件的新增/修改/删除，旧版本(git 1.x)默认情况下不会处理文件删除（即如果index中存在文件A，同时在工作目录删除A，则<code>add</code>不会在index中删除A），高版本默认处理文件删除，即 <code>git add .</code>等价于 <code>git add --all</code></li>
<li><code>pathspec</code>：所要处理的文件名称规则，支持通配符，支持多个</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git add .</code>
<ul>
<li>添加当前目录的所有变更到暂存区</li>
</ul>
</li>
<li><code>git add dir/\*.c</code>
<ul>
<li>添加dir目录<strong>及其子目录</strong>中所有c文件变更到暂存区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-rm">git rm</h4>
<pre tabindex="0"><code>git rm
	[--dry-run | -n]
	[--force | -f]
	[--cached]
	[-r]
	[--]
	&lt;pathspec&gt;...
</code></pre><ul>
<li>作用
<ul>
<li>从暂存区和工作目录中删除文件</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-n</code>：不实际删除，只输出将要进行的操作</li>
<li><code>-f</code>：强制删除，默认情况下，<code>rm</code>的文件要求必须未经过修改（即HEAD中的文件内容与index中的文件内容与工作目录中的文件内容相同），通过此选项可以强制删除(暂存区和工作目录)</li>
<li><code>--cached</code>：仅在暂存区域中删除文件，保留工作目录中的文件</li>
<li><code>-r</code>：对<code>pathspec</code>指定的目录递归执行</li>
<li><code>--</code>：作为命令和文件名称的分隔符，以避免文件名被视为命令选项</li>
<li><code>pathspec</code>：要删除的文件名称规则</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git rm -r d</code>
<ul>
<li>递归删除目录d</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-mv">git mv</h4>
<pre tabindex="0"><code>git mv
	[--dry-run | -n]
	[--force | -f]
	[-k]
	&lt;source&gt;...  &lt;destination&gt;
</code></pre><ul>
<li>作用
<ul>
<li>移动或者重命名文件</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-n</code>：空运行</li>
<li><code>-k</code>：出错时跳过</li>
<li><code>-f</code>：强制执行，即使目标文件名已存在</li>
<li><code>source</code>：源文件名称，可多个</li>
<li><code>destination</code>：目标文件名称，可为目录，可不存在</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git mv t1 t2 d</code>
<ul>
<li>将文件t1、t2移动到目录d</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-restore">git restore</h4>
<pre tabindex="0"><code>git restore
	[--source=&lt;tree&gt; | -s &lt;tree&gt;]
	[--worktree | -W]
	[--staged | -S]
	[--ours] [--theirs]
	[--merge | -m]
	[--]
	&lt;pathspec&gt;...
</code></pre><ul>
<li>作用
<ul>
<li>撤销/还原工作目录的修改，默认情况下将工作目录还原到暂存区状态</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-s</code>：源对象（要把文件还原/恢复到源对象）
<ul>
<li>指定 <code>-W</code>选项时，默认<code>source</code>为index，即将工作目录的修改还原到暂存内容index</li>
<li>指定 <code>-S</code>选项时，默认<code>source</code>为HEAD，即将暂存区还原到HEAD</li>
<li>也可以指定其他提交ID</li>
</ul>
</li>
<li><code>-W</code>：执行还原操作的对象为工作目录，即把工作目录还原到index，默认此选项
<ul>
<li>原理：将INDEX拷贝复原到WD</li>
</ul>
</li>
<li><code>-S</code>：执行还原操作的对象为暂存区域，即把index还原到HEAD
<ul>
<li>原理：将COMMIT(默认INDEX)拷贝复原到INDEX</li>
</ul>
</li>
<li><code>--ours</code>：当要还原出现合并冲突的文件时，<code>ours</code>选项表明将冲突文件还原到当前分支</li>
<li><code>--theirs</code>：当要还原出现合并冲突的文件时，<code>theirs</code>选项表明将冲突文件还原到合并目标分支</li>
<li><code>--merge</code>：表明重新将文件还原到合并冲突的状态</li>
<li><code>--</code>：分隔命令选项和文件名称，表明后续全为文件名称</li>
<li><code>pathspec</code>：文件名称，可多个</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git restore -s HEAD^ -WS .</code>
<ul>
<li>将工作目录和暂存区的修改都撤销，还原到HEAD前一个提交</li>
</ul>
</li>
<li><code>git restore --ours txt</code>
<ul>
<li>将合并冲突的txt还原到我方分支内容</li>
</ul>
</li>
</ul>
</li>
<li>备注
<ul>
<li>git 2.23版本新增，用于拆解checkout命令的功能</li>
</ul>
</li>
</ul>
<h4 id="git-checkout">git checkout</h4>
<pre tabindex="0"><code>git checkout
	[&lt;tree&gt;]
	[--ours] [--theirs]
	[--merge | -m]
	[--]
	&lt;pathspec&gt;...
</code></pre><ul>
<li>作用
<ul>
<li>此形式下用于撤销/还原工作目录修改，默认情况下将工作目录还原到暂存区状态</li>
</ul>
</li>
<li>原理
<ul>
<li><del>默认情况下：将INDEX拷贝复原到WD</del></li>
<li><del>指定tree时：将COMMIT拷贝复原到INDEX，然后将INDEX拷贝复原到WD</del></li>
</ul>
</li>
<li>选项
<ul>
<li><code>tree</code>：要还原到的源对象（默认情况下为index）</li>
<li><code>--ours</code>：当要还原出现合并冲突的文件时，<code>ours</code>选项表明将冲突文件还原到当前分支</li>
<li><code>--theirs</code>：当要还原出现合并冲突的文件时，<code>theirs</code>选项表明将冲突文件还原到合并目标分支</li>
<li><code>--merge</code>：表明重新将文件还原到合并冲突的状态</li>
<li><code>--</code>：分隔命令选项和文件名称，表明后续全为文件名称</li>
<li><code>pathspec</code>：文件名称，可多个，必选</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git checkout HEAD -- .</code>
<ul>
<li>将当前暂存区和工作目录全部还原到HEAD</li>
</ul>
</li>
</ul>
</li>
<li>备注
<ul>
<li>这是checkout用于撤销/还原工作目录的功能用法</li>
<li>此形式中必须指定<code>pathspec</code></li>
</ul>
</li>
</ul>
<h4 id="git-reset">git reset</h4>
<pre tabindex="0"><code>git reset
	[&lt;tree&gt;]
	[--]
	&lt;pathspec&gt;...
</code></pre><ul>
<li>作用
<ul>
<li>此形式下用于还原暂存区INDEX到指定的TREE，而不会修改工作目录，默认情况下TREE为HEAD</li>
</ul>
</li>
<li>选项
<ul>
<li><code>tree</code>：源提交</li>
<li><code>--</code>：分隔命令选项和文件名称，表明后续全为文件名称</li>
<li><code>pathspec</code>：文件名称，可多个，必选</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git reset .</code>
<ul>
<li>将此时暂存区IDNEX还原到HEAD</li>
</ul>
</li>
</ul>
</li>
<li>备注
<ul>
<li>此形式下reset用于还原INDEX</li>
<li>此形式下<code>pathspec</code>必选</li>
</ul>
</li>
</ul>
<h4 id="git-revert-1">git revert</h4>
<pre tabindex="0"><code>git revert
	[--no-commit | -n]
	&lt;commit&gt;...

git revert (--continue | --skip | --abort | --quit)
</code></pre><ul>
<li>作用
<ul>
<li>通过生成新提交的方式撤销某个指定的提交</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--n</code>：撤销指定的提交，只将撤销操作应用到INDEX和WD，而不生成新提交</li>
<li><code>commit</code>：指定的提交，可多个，必选</li>
</ul>
</li>
</ul>
<h4 id="git-clean">git clean</h4>
<pre tabindex="0"><code>git clean
	[--dry-run | -n]
	[--force | -f]
	[--interactive | -i]
	[-d]
	[-e &lt;pattern&gt;]
	[-x] 
	[-X]
	[&lt;path&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>从工作目录中移除未跟踪文件/untracked files（未添加到暂存区域index的文件），默认情况下不会移除未跟踪目录（如果未指定path）、不会移除 <code>.gitignore</code>指定忽略的文件</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-n</code>：试运行，输出将要清除的文件</li>
<li><code>-f</code>：如果git配置中 <code>clean.requireForce</code>变量没有设置为false(默认为true)，则只有带有此选项才能真正删除</li>
<li>`-i：交互式执行clean</li>
<li><code>-d</code>：移除未跟踪目录</li>
<li><code>-e</code>：增加忽略规则，命中规则的文件不会清除</li>
<li><code>-x</code>：同时移除命中 <code>.gitignore</code>文件中规则的文件</li>
<li><code>-X</code>：仅移除命中 <code>.gitignore</code>文件中规则的文件</li>
<li><code>path</code>：指定清除的文件规则，可多个，可选，为空时为当前目录</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git clean -f .</code>
<ul>
<li>移除当前目录中的未跟踪文件，不包括命中<code>.gitignore</code>的文件，包括未跟踪目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-stash">git stash</h4>
<pre tabindex="0"><code>git stash
	push
		[--keep-index | -k] 
		[--all | -a]
		[--message | -m]
		[--]
		[&lt;pathspec&gt;...]
	list
		
	show
		[-p]
		[&lt;stash&gt;]
	pop
		[--index]
		[&lt;stash&gt;]
	apply
		[--index]
		[&lt;stash&gt;]
	branch
		&lt;branchname&gt;
		[&lt;stash&gt;]
	clear
	
	drop
		[&lt;stash&gt;]
</code></pre><ul>
<li>作用
<ul>
<li>将目前已经修改但不想提交的内容（工作目录和暂存区）保存到堆栈区，使工作目录和暂存区恢复clean状态，后续可根据需要在某个分支/时刻恢复出堆栈区的内容</li>
</ul>
</li>
<li>原理
<ul>
<li><code>stash</code>命令<code>push</code>的过程实际上是对此时的暂存区和工作区分别创建一个提交，同时通过 <code>.git/refs/stash</code>引用最新一个stash的提交，之前进行过的stash创建的提交对象通过stash引用的reflog来进行定位</li>
<li><code>stash</code>命令<code>pop</code>的过程实际上就是对stash引用的提交和当前工作目录执行一个合并操作</li>
</ul>
</li>
<li>选项
<ul>
<li><code>push</code>
<ul>
<li>保存工作目录和暂存区到stash</li>
<li><code>-k</code>：不stash暂存区，只stash工作目录，仍然保留暂存区状态</li>
<li><code>-a</code>：所有忽略和未跟踪的文件都会加入到stash提交中，然后执行clean</li>
<li><code>-m</code>：对本次stash的说明</li>
<li><code>pathspec</code>：只对命中path的文件进行stash和还原，可多个，可选</li>
</ul>
</li>
<li><code>list</code>
<ul>
<li>展示全部stash的提交，可使用<code>log</code>命令的相关选项</li>
</ul>
</li>
<li><code>show</code>
<ul>
<li>展示某个stash提交的变更diff（stash提交与进行stash操作时所在HEAD的提交的diff，而非stash提交与当前工作目录的diff）</li>
<li><code>-p</code>：展示具体diff</li>
<li>同时可使用<code>diff</code>命令的相关选项</li>
</ul>
</li>
<li><code>pop</code>
<ul>
<li>应用并弹出某个stash提交，默认情况下应用弹出最新一次stash提交</li>
<li><code>--index</code>：同时恢复stash的暂存区的提交到当前暂存区，默认情况下仅恢复工作目录</li>
</ul>
</li>
<li><code>apply</code>
<ul>
<li>应用某个stash提交，但不弹出</li>
</ul>
</li>
<li><code>drop</code>
<ul>
<li>移除某个stash提交</li>
</ul>
</li>
<li><code>clear</code>
<ul>
<li>清空全部stash提交</li>
</ul>
</li>
<li><code>branch</code>
<ul>
<li>在进行stash的提交处新建一个分支，然后把stash提交应用到此分支</li>
</ul>
</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git stash push -m &quot;func&quot;</code>
<ul>
<li>将当前工作区和暂存区进行stash</li>
</ul>
</li>
<li><code>git show -p stash^</code>
<ul>
<li>查看前一个stash提价的diff</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-status">git status</h4>
<pre tabindex="0"><code>git status
	[--short]
	[--verbose | -v]
	[-vv]
	[--]
	[&lt;pathspec&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>展示当前HEAD、INDEX、WD三者之间的区别</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--short</code>：通过短形式展示
<ul>
<li>绿色：HEAD和INDEX之间的区别</li>
<li>红色：INDEX和WD之间的区别</li>
<li>A：新增文件</li>
<li>D：删除文件</li>
<li>M：修改文件</li>
<li>R：重命名</li>
<li>U：合并冲突</li>
<li>T：文件类型改变</li>
<li>?：文件未跟踪</li>
<li>!：文件已忽略</li>
</ul>
</li>
<li><code>-v</code>：同时展示HEAD和INDEX的diff</li>
<li><code>-vv</code>：同时展示HEAD和INDEX的diff，以及INDEX和WD的diff</li>
<li><code>--</code>：分隔命令选项和文件名称，表明后续全为文件名称</li>
<li><code>pathspec</code>：文件名称，可多个，必选</li>
</ul>
</li>
</ul>
<h4 id="git-diff-1">git diff</h4>
<pre tabindex="0"><code>git diff
	[--cached]
	[&lt;commit&gt;]
	[&lt;commitA&gt; &lt;commitB&gt;]
	[--]
	[&lt;path&gt;...]
</code></pre><ul>
<li>
<p>作用</p>
<ul>
<li>输出不同提交之间的diff，默认情况下输出INDEX到WD的diff</li>
</ul>
</li>
<li>
<p>选项</p>
<ul>
<li><code>--cached</code>：输出HEAD到INDEX的diff</li>
<li><code>commit</code>：输出COMMIT到WD（或者INDEX）的diff</li>
<li><code>commitA commitB</code>：输出commitA到commitB的diff</li>
<li><code>--</code>：分隔命令选项和文件名称，表明后续全为文件名称</li>
<li><code>path</code>：文件名称，可多个，必选</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li>
<p><code>git diff --cached HEAD^</code></p>
<ul>
<li>输出HEAD^到INDEX的diff</li>
</ul>
</li>
<li>
<p><code>git diff</code></p>
<ul>
<li>输出INDEX到WD的diff</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-commit">git commit</h4>
<pre tabindex="0"><code>git commit
	[--dry-run]
	[--all | -a]
	[--amend]
	[-m &lt;msg&gt; | --message=&lt;msg&gt;]
	[--]
	[&lt;pathspec&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>将INDEX中的内容进行提交</li>
<li>将INDEX打包成COMMIT对象，其中当前HEAD为此COMMIT的父提交对象，然后将此提交加到HEAD指向的分支顶部</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--dry-run</code>：试运行，只输出变更的文件</li>
<li><code>-a</code>：自动将已跟踪文件中进行变更/删除的文件加到暂存区然后进行提交，但不会添加未跟踪文件</li>
<li><code>--amend</code>：在当前提交的前一提交的基础上创建一个新提交，保存当前提交的修改和最新修改，然后将HEAD指向新提交</li>
<li><code>-m</code>：指定提交信息</li>
<li><code>--</code>：分隔命令选项和文件名称，表明后续全为文件名称</li>
<li><code>pathspec</code>：文件名称，可多个，可选，用来指定本次提交包含的文件</li>
</ul>
</li>
</ul>
<h4 id="git-tag">git tag</h4>
<pre tabindex="0"><code>git tag
	[--annotate | -a]
	[--force | -f]
	[--delete | -d]
	[--message=&lt;msg&gt; | -m &lt;msg&gt;]
	[--file=&lt;file&gt; | -F &lt;file&gt;]
	[-v]
	&lt;tagname&gt;
	[&lt;commit&gt;]
</code></pre><ul>
<li>作用
<ul>
<li>创建/展示/删除tag</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-a</code>：创建附注标签</li>
<li><code>-f</code>：替换tag</li>
<li><code>-d</code>：删除tag</li>
<li><code>-m</code>：tag信息，用于附注标签</li>
<li><code>-F</code>：文件内容作为tag信息，用于附注标签</li>
<li><code>-v</code>：显示tag内容</li>
<li><code>tagname</code>：标签名称</li>
<li><code>commit</code>：指定对某个提交创建tag，可选，默认为HEAD</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git tag -a -m &quot;tag: 1.0&quot; v1.0</code>
<ul>
<li>创建附注标签v1.0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分支">分支</h3>
<h4 id="git-branch">git branch</h4>
<pre tabindex="0"><code>git branch
	[--list | -l]
	[--verbose | -v]
	[--remotes | -r]
	[-all | -a]
	
git branch 
	[-f] 
	&lt;branchname&gt; [&lt;commit&gt;]

git branch 
	(--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) 
	[&lt;branchname&gt;]

git branch 
	--unset-upstream 
	[&lt;branchname&gt;]

git branch 
	[-m | -M]
	[-c | -C]
	[&lt;oldbranch&gt;] &lt;newbranch&gt;

git branch 
	(-d | -D) 
	[-r] 
	&lt;branchname&gt;...
</code></pre><ul>
<li>作用
<ul>
<li>查看、创建、变更Git分支</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-l</code>：查看本地分支</li>
<li><code>-r</code>：查看本地保存的远程分支</li>
<li><code>-a</code>：查看本地分支和远程分支</li>
<li><code>-v</code>：展示分支的详细信息，包括最新提交</li>
<li><code>-f</code>：强制创建/更改，即使分支已存在</li>
<li><code>branchname</code>：分支名称</li>
<li><code>commit</code>：分支引用的提交</li>
<li><code>-u</code>：设置分支的远程跟踪分支，用于拉取合并</li>
<li><code>--unset-upstream</code>：移除分支的远程跟踪分支</li>
<li><code>-m</code>：分支重命名，默认当前分支</li>
<li><code>-M</code>：分支强制重命名，即使新分支已存在，即 <code>-m -f</code></li>
<li><code>-c</code>：分支复制，默认当前分支</li>
<li><code>-C</code>：分支强制复制，即使新分支已存在，即 <code>-c -f</code></li>
<li><code>-d</code>：分支删除，可多个，与 <code>-r</code>连用可删除本地保存的远程分支</li>
<li><code>-D</code>：分支强制删除</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git branch -d -r origin/todo</code>
<ul>
<li>删除远程分支todo，注意如果没有显示配置，则下次执行<code>pull</code>或<code>fetch</code>命令时仍然会创建对应的远程分支</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-switch">git switch</h4>
<pre tabindex="0"><code>git switch
	[-c | -C]
	[--merge | -m]
	&lt;branch&gt; [&lt;commit&gt;]

git switch
	--detach
	[&lt;commit&gt;]
</code></pre><ul>
<li>作用
<ul>
<li>切换分支</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-c</code>：创建分支，初始指向<code>commit</code>，默认为HEAD</li>
<li><code>-C</code>：强制创建分支，即使分支已存在</li>
<li><code>-m</code>：切换分支时进行三方合并（HEAD+WD+BRANCH）</li>
<li><code>--detach</code>：切换到<code>commit</code>，不创建新分支，HEAD直接指向<code>commit</code>而不是指向引用</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git switch -</code>
<ul>
<li>切换到上次所在分支</li>
</ul>
</li>
<li><code>git switch dev</code>
<ul>
<li>切换到dev分支，如果dev分支不存在，但是存在远程同名分支（例如 <code>origin/dev</code>），则会基于此远程分支自动创建分支dev，同时设置两者的跟踪关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-checkout-1">git checkout</h4>
<pre tabindex="0"><code>git checkout
	[--detach]
	[--merge | -m]
	[-b | -B]
	[--orphan]
	&lt;branch&gt; [&lt;commit&gt;]
</code></pre><ul>
<li>作用
<ul>
<li>切换分支</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-b</code>：创建分支，初始指向<code>commit</code>，默认为HEAD</li>
<li><code>-B</code>：强制创建分支，即使分支已存在</li>
<li><code>-m</code>：切换分支时进行三方合并（HEAD+WD+BRANCH）</li>
<li><code>--detach</code>：切换到<code>commit</code>，不创建新分支，HEAD直接指向<code>commit</code>而不是指向引用</li>
<li><code>--orphan</code>：创建孤儿分支，即分支不包括任何提交，但包括<code>commit</code>的暂存区和工作目录</li>
</ul>
</li>
</ul>
<h4 id="git-reset-1">git reset</h4>
<pre tabindex="0"><code>git reset
	[--soft | --mixed | --hard]
	&lt;commit&gt;
</code></pre><ul>
<li>作用
<ul>
<li>重置HEAD到指定状态</li>
</ul>
</li>
<li>原理
<ul>
<li><code>reset</code>命令不指定特定文件时的一般过程是
<ul>
<li>移动HEAD指向分支的指向（注意不是直接改变HEAD，而是改变HEAD指向分支）</li>
<li>复制此时HEAD到INDEX</li>
<li>复制INDEX到WD</li>
</ul>
</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--soft</code>：只进行第一步，即改变HEAD指向分支的顶部提交为<code>commit</code>，同时不改变当前的INDEX和WD</li>
<li><code>--mixed</code>：进行第一步第二步，默认情况</li>
<li><code>--hard</code>：进行第一步第二步第三步</li>
</ul>
</li>
</ul>
<h4 id="git-merge">git merge</h4>
<pre tabindex="0"><code>git merge
	[--no-commit | --commit]
	[--ff | --no-ff | --ff-only]
	[-s &lt;strategy&gt; | --strategy=&lt;strategy&gt;]
	[-m &lt;msg&gt; | --message=&lt;msg&gt;]
	[&lt;commit&gt;...]

git merge 
	[--continue | --quit | --abort]
</code></pre><ul>
<li>作用
<ul>
<li>在当前分支合并参数分支的修改</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--no-commit</code>：合并分支，但不进行提交，用于检查修改，默认是 <code>--commit</code>，即创建提交</li>
<li><code>-ff</code>：如果当前分支和参数分支存在亲代关系，则直接通过移动指针的方式进行合并，不创建新提交，<code>--no-ff</code>会创建一个新提交（尽管提交的内筒仍然是最新提交的内容）</li>
<li><code>-s</code>：指定合并策略，默认为 <code>ort</code></li>
<li><code>-m</code>：合并信息</li>
<li><code>commit</code>：要合并的提交，可多个，可选，为空时默认合并当前分支的远程跟踪分支</li>
</ul>
</li>
</ul>
<h4 id="git-rebase-1">git rebase</h4>
<pre tabindex="0"><code>git rebase
	[-i | --interactive]
	[--exec &lt;cmd&gt;]
	[--apply | --merge]
	[--onto &lt;base&gt;]
	[&lt;start&gt; [&lt;end&gt;]]
git rebase
	[--continue | --skip | -abort | --quit]
</code></pre><ul>
<li>
<p>作用</p>
<ul>
<li>将部分提交所作的修改重新应用到指定的基准提交</li>
<li>具体而言，将<code>start</code>到<code>end</code>的左闭右开范围提交（即 <code>&lt;start&gt;..&lt;end&gt;</code>，即 <code>&lt;end&gt;</code>提交链中除去 <code>&lt;start&gt;</code>提交链的部分）重新应用到<code>base</code>，未指定<code>base</code>时，默认<code>base</code>为<code>start</code>，未指定<code>end</code>时，<code>end</code>为HEAD，未指定<code>start</code>时，<code>start</code>为HEAD的远程跟踪分支（对应配置项中的<code>branch.&lt;name&gt;.remote &amp;&amp; branch.&lt;name&gt;.merge</code>）</li>
</ul>
</li>
<li>
<p>选项</p>
<ul>
<li>
<p><code>-i</code>：交互式进行rebase，即将<code>&lt;start&gt;..&lt;end&gt;</code>的每个提交手动进行处理，支持若干动词</p>
</li>
<li>
<p><code>--exec</code>：在应用每个<code>commit</code>后，通过shell执行<code>cmd</code>命令</p>
</li>
<li>
<p><code>--apply</code>：指定通过提取patch然后apply的方式进行变基</p>
</li>
<li>
<p><code>--merge</code>：指定通过三路合并的merge方式进行变基，默认方式</p>
</li>
<li>
<p><code>--onto</code>：手动指定base，默认为start</p>
</li>
</ul>
</li>
<li>
<p>交互-动词</p>
<ul>
<li>
<img style="display:none;" src="" alt="image-20221201203657727" title="" mask=true data-mask="2c5b9dd0a9e037abfe3811ae95aa2c5e1eeda75b8ba18e4e0f066fad8f2a3a9a4fab9f162a1a53091a597f58dfcf478ae7d6c85bfc3b0ba3fe70962e1571db7e547788dc129c67faff86d2028e89ac9648700b0406a17b22dde25d104fc4aa89 4669a221924964b0633212b4b62c5e465ada573f39b48f598614f7b2ceb4861152e47ed2c4930f8e14f04a707124fe532d010b3122cb4070b1b332024a1c01834a8461a2d7813cf5856b32208a7272806d4bf788ab347d9e10ba4ed495180ead" data-sign="faf4f20ddfa7c8634f0ef76f1a12c738a95be5ae 3cae33df0bbc6e55f3d3c4240e0c406c3cb6081b" data-expire="43012137600000 253392422400000" data-algo="AES" data-cookie="oss"/>
</li>
<li>具体方式是：
<ul>
<li>命令面板自上而下是<code>start</code>到<code>end</code>的左闭右开范围提交（即 <code>&lt;start&gt;..&lt;end&gt;</code>）</li>
<li><code>rebase</code>命令会自上而下应用每个提交到<code>base</code>，同时更新<code>base</code>
<ul>
<li><code>pick</code>：不作处理，直接采用此提交</li>
<li><code>reword</code>：采用提交，但弹出编辑面板用于编辑提交信息</li>
<li><code>edit</code>：采用提交，然后停止，通过执行 <code>git commit --amend</code>命名增补此提交，然后执行 <code>git rebase --continue</code>继续</li>
<li><code>squash</code>：采用提交，但把此提交压缩到上一个提交（即此时的HEAD不移动），弹出编辑面板用于编辑提交信息</li>
<li><code>fixup</code>：默认仅保留上一提交信息，指定 <code>-C</code>时仅保留选项中的<code>commit</code>的提交信息</li>
<li><code>exec</code>：通过shell运行命令</li>
<li><code>break</code>：暂停</li>
<li><code>drop</code>：舍弃此提交</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li><code>git rebase</code>
<ul>
<li>将HEAD在 <code>&lt;origin&gt;/&lt;branch&gt;</code>之外的提交重新应用/变基到 <code>&lt;origin&gt;/&lt;branch&gt;</code></li>
</ul>
</li>
<li><code>git rebase master</code>
<ul>
<li>将HEAD在master之外的提交重新应用/变基到master</li>
</ul>
</li>
<li><code>git rebase master featA</code>
<ul>
<li>将featA在master之外的提交重新应用/变基到master，同时自动切换到featA</li>
</ul>
</li>
<li><code>git rebase --onto master featA featAB</code>
<ul>
<li>将featAB在featA之外的提交重新应用/变基到master</li>
</ul>
</li>
<li><code>git rebase -i HEAD~3 </code>
<ul>
<li>将HEAD在<code>HEAD~3</code>之外的提交重新应用/变基在<code>HEAD~3</code>，同时通过交互的方式处理每个提交</li>
<li>重写 <code>HEAD~2 HEAD~1 HEAD</code>三个提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="历史">历史</h3>
<h4 id="git-log">git log</h4>
<pre tabindex="0"><code>git log [&lt;options&gt;] [&lt;revision-range&gt;] [[--] &lt;path&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>查看某个提交/引用/范围的提交日志</li>
<li>具体：以<code>options</code>格式展示 <code>revision-range</code>提交范围中对 <code>path...</code>文件进行变更的所有提交
<ul>
<li><code>revision-range</code>：给定单提交时为该提交的提交链，为空时为HEAD的提交链</li>
</ul>
</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git log --oneline master -- h.cpp </code>
<ul>
<li>通过oneline格式展示master提交链中对 <code>h.cpp</code>进行变更的所有提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-reflog">git reflog</h4>
<pre tabindex="0"><code>git reflog [show] 
			[&lt;log-options&gt;] 
			[&lt;ref&gt;]
			
git reflog expire 
			[--expire=&lt;time&gt;] 
			[--expire-unreachable=&lt;time&gt;]
			[--rewrite] [--updateref] [--stale-fix]
			[--dry-run | -n] [--verbose] 
			[--all [--single-worktree] | &lt;refs&gt;...]
			
git reflog delete 
			[--rewrite] 
			[--updateref]
			[--dry-run | -n] [--verbose] 
			&lt;ref&gt;@{&lt;specifier&gt;}...
			
git reflog exists &lt;ref&gt;
</code></pre><ul>
<li>作用
<ul>
<li>管理每个引用的reflog信息</li>
</ul>
</li>
<li>选项
<ul>
<li><code>show</code>：展示某个引用的reflog，接受<code>log</code>的所有选项同时遵循其格式，默认展示HEAD引用</li>
<li><code>expire</code>：删除已经过期的reflog</li>
<li><code>delete</code>：删除某个reflog的单个entry</li>
<li><code>exists</code>：查看某个引用是否有reflog</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git reflog</code>
<ul>
<li>查看HEAD的reflog</li>
</ul>
</li>
<li><code>git reflog featA --</code>
<ul>
<li>查看featA的reflog，后续 <code>--</code>必选，因为此命令接受<code>log</code>格式，必须通过 <code>--</code>来划分引用名和文件名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-show">git show</h4>
<pre tabindex="0"><code>git show [&lt;options&gt;] [&lt;object&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>展示各种类型的Git对象</li>
</ul>
</li>
<li>类型
<ul>
<li><code>commit</code>
<ul>
<li>展示提交对象的提交信息以及文本diff</li>
</ul>
</li>
<li><code>tag</code>
<ul>
<li>展示tag对象的标签信息和引用的提交对象</li>
</ul>
</li>
<li><code>tree</code>
<ul>
<li>展示tree对象的名称</li>
</ul>
</li>
<li><code>blob</code>
<ul>
<li>展示blob对象的内容</li>
</ul>
</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git show HEAD</code>
<ul>
<li>展示HEAD引用提交的信息和diff</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-describe">git describe</h4>
<pre tabindex="0"><code>git describe
	[--all]
	[--tags]
	[--contains]
	&lt;commit&gt;
</code></pre><ul>
<li>作用
<ul>
<li>为<code>commit</code>返回一个可读性高的版本名称</li>
<li>默认情况下，找到<code>commit</code>亲代中最近的附注tag，然后根据标签名称、代际数、当前提交sha-1生成可读的提交名称</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--all</code>：在所有的引用中查找</li>
<li><code>--tags</code>：在所有的tags中查找，包括轻量级标签和附注标签</li>
<li><code>--contains</code>：在<code>commit</code>的子代中找最近的tag</li>
</ul>
</li>
</ul>
<h4 id="git-blame">git blame</h4>
<pre tabindex="0"><code>git blame
	[-L &lt;range&gt;]
	[--]
	&lt;file&gt;
</code></pre><ul>
<li>作用
<ul>
<li>追溯一个指定文件的历史修改记录，展示哪个author对文件的每一行做了什么修改</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-L</code>：指定范围
<ul>
<li><code>&lt;start&gt;,&lt;end&gt;</code>：start到end行</li>
<li><code>&lt;start&gt;,+&lt;offset&gt;</code>：start到start+offset行</li>
<li><code>&lt;start&gt;,/regex/</code>：start到匹配 <code>/regex/</code>行</li>
</ul>
</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git blame -L '/^sub hello {/,/^}$/' foo</code>
<ul>
<li>追溯从 <code>sub hello {</code>到 <code>}</code>的行的历史修改记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="远程">远程</h3>
<h4 id="git-remote">git remote</h4>
<pre tabindex="0"><code>git remote add &lt;name&gt; &lt;URL&gt;
git remote rename &lt;old&gt; &lt;new&gt;
git remote remove &lt;name&gt;
</code></pre><ul>
<li>作用
<ul>
<li>管理远程仓库</li>
</ul>
</li>
</ul>
<h4 id="git-fetch">git fetch</h4>
<pre tabindex="0"><code>git fetch
	[--all]
	[--set-upstream]
	[&lt;repository&gt;]
	[&lt;refspec&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>从远程仓库下载对象和引用</li>
</ul>
</li>
<li>refspec
<ul>
<li>引用规则的格式为： <code>[+]&lt;src&gt;:&lt;dst&gt;</code>
<ul>
<li><code>+</code>：即使在不能fast-forward的情况下也要强制更新引用</li>
<li><code>src</code>：源引用</li>
<li><code>dst</code>：目的引用</li>
</ul>
</li>
<li>可通过修改refspec的形式，自定义远程分支的位置、远程分支拉取到本地分支的位置、拉取哪些远程分支、推送哪些分支到远程分支；也可以通过<code>git push/fetch origin &lt;src&gt;:&lt;dst&gt;</code>的形式手动指定本次f/p操作</li>
<li>可将<code>src</code>留空以删除远程版本库的<code>dst</code></li>
</ul>
</li>
<li>选项
<ul>
<li><code>--set-upstream</code>：fetch成功后将fetch的所有分支和本地对应分支设置为track关系，以供<code>pull</code>和<code>push</code>使用</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git fetch origin</code>
<ul>
<li>获取远程仓库remote的所有分支，然后保存到本地 <code>.git/refs/remotes/origin</code></li>
</ul>
</li>
<li><code>git fetch origin b</code>
<ul>
<li>将远程仓库origin的b分支更新到本地远程分支b</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-pull">git pull</h4>
<pre tabindex="0"><code>git pull
	[-r | --rebase]
	[&lt;repository&gt;]
	[&lt;refspec&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>拉取远程分支，然后和本地分支合并</li>
</ul>
</li>
<li>原理
<ul>
<li>首先fetch到本地远程分支</li>
<li>然后将本地远程分支合并到本地分支</li>
</ul>
</li>
<li>选项
<ul>
<li><code>-r</code>：通过rebase方式合并，默认merge</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git pull origin main:master</code>
<ul>
<li>将远程仓库origin的main分支下载到本地远程分支main，然后合并到本地master分支</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="git-push">git push</h4>
<pre tabindex="0"><code>git push
	[--all]
	[--prune]
	[-n | --dry-run]
	[-f | --force]
	[-d | --delete]
	[-u | --set-upstream]
	[-v | --verbose]
	[&lt;repository&gt;]
	[&lt;refspec&gt;...]
</code></pre><ul>
<li>作用
<ul>
<li>使用本地引用更新远程引用，并且通过<code>smart</code>协议将远程缺失的提交上传</li>
<li>语义：将远程引用<code>remote</code>所指向的提交对象设置为<code>local</code>指向的提交对象
<ul>
<li>默认情况下远程仓库只会在可以进行fast-forward的时候才会设置成功</li>
<li>通过<code>force</code>选项可以强制覆盖，因此<code>remote</code>远程分支之前引用的提交对象会变dangle，因此可能在<code>gc</code>中移除</li>
</ul>
</li>
</ul>
</li>
<li>选项
<ul>
<li><code>--all</code>：全部本地分支</li>
<li><code>--prune</code>：删除没有本地对应分支的远程分支</li>
<li><code>-n</code>：试运行</li>
<li><code>-d</code>：删除列出的远程分支</li>
<li><code>-f</code>：强制覆盖，即使不能fast-forward</li>
<li><code>-u</code>：push成功后，自动添加远程跟踪配置</li>
<li><code>repository</code>：要推送到的远程仓库，可以是仓库URL，也可以是远程仓库的名称（<code>remote</code>命令所添加的），默认（<code>branch.*.remote</code>配置，再默认<code>origin</code>）</li>
</ul>
</li>
<li>实例
<ul>
<li><code>git push</code>
<ul>
<li>推送当前分支到配置的远程分支</li>
</ul>
</li>
<li><code>git push origin master</code>
<ul>
<li>推送本地master到origin的远程master</li>
</ul>
</li>
<li><code>git push origin :dev</code>
<ul>
<li>删除远程dev</li>
</ul>
</li>
<li><code>git push origin +dev:master</code>
<ul>
<li>把远程master重置为本地dev的提交</li>
</ul>
</li>
</ul>
</li>
</ul>
      
      
    </div>

    
		<div class="post-cats-box">
      
      
      <a class="tag-link" href="/categories/%E6%8A%80%E6%9C%AF">技术</a> 
      
		</div>
		

    
    
    <div class="post-tags-box">
      
      
      <a class="tag-link" href="/tags/git">Git</a> 
      
    </div>
    
    

  </article>
</div>

<div class="post-nav">
  
  <div class="prev-wrap col-md-6 col-xs-6">
    <i class="fa fa-angle-double-left"></i>
    <a href="https://brycerd.github.io/posts/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" class="prev-post">程序架构设计基础</a>
  </div>
  

  
</div>


    <div id="toc"></div>
    </main>
</div>


  <div id="local-search">
    <div class="search-dialog">
        <div class="search-nav">
            <span class="search-dialog-title">搜索</span>
            <span id="loading-status"></span>
            <button class="search-close-button">
                <i class="iconfont icon-quxiao4"></i>
            </button>
        </div>
        <div class="is-center" id="loading-database">
            <i class="fas fa-spinner fa-pulse"></i>
            <span>数据库载入中</span>
        </div>
        <div class="search-wrap">
            <div id="local-search-input">
                <div class="local-search-box">
                    <input class="local-search-box--input" placeholder="请输入关键词" type="text">
                </div>
            </div>
            <hr>
            <div id="local-search-results">
            </div>
        </div>
    </div>
    <div id="search-mask"></div>
</div>


<div id="login">
    <div class="login-box">
        <p class="login-nav">
            <span class="login-title">LOGIN</span>
            <span id="loading-status"></span>
            <button class="login-close-button">
                <i class="iconfont icon-quxiao4"></i>
            </button>
        </p>
		<div class="item">
			<input type="text" id="user" required>
			<label for="">USER</label>
		</div>
		<div class="item">
			<input type="password" id="password" required>
			<label for="">PASSWORD</label>
		</div>
		<button class="btn" id="login-submit">submit
			<span></span>
			<span></span>
			<span></span>
			<span></span>
		</button>
    </div>
    <div id="login-mask">
    </div>
</div>
<footer>
  <div class="copyright">
    <p id="copyright">Copyright © &nbsp;Bryce&nbsp;2022 - 2023&nbsp;
    </p>
    <p>
      Powered by
      <a href="https://gohugo.io/" target="_blank">Hugo</a>&nbsp;&
      <a href="https://github.com/GenkunAbe/hugo-theme-hiruko" target="_blank">Hiruko</a>
    </p>
  </div>
</footer>

<script>
(function (u, c) {
    var d = document, t = 'script', o = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(e); }); }
    s.parentNode.insertBefore(o, s);
})("/libs/pangu/pangu.min.js", function () {
    pangu.spacingPage();
});
</script>
<link rel="stylesheet" href="/libs/katex/css/katex.min.css">
<script defer src="/libs/katex/js/katex.min.js"></script>
<script defer src="/libs/katex/js/auto-render.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          macros: {
            "\\ge": "\\geqslant",
            "\\le": "\\leqslant",
            "\\geq": "\\geqslant",
            "\\leq": "\\leqslant"
            },
          
          throwOnError : false
        });
    });
</script>
<link rel="stylesheet" href="/libs/highlight.js/styles/gradient-light.min.css"/>
<script src="/libs/highlight.js/highlight.min.js"></script>
<script src="/libs/highlightjs-line-numbers.js/highlightjs-line-numbers.min.js"></script>
<script src="/libs/highlight.js/languages/shell.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad({
    singleLine: true
});
</script>
<script>
    if (typeof show_toc == 'undefined') {
        var show_toc = true;
    }
    if (show_toc) {
        $("#toc").tocify({
            selectors: "h2,h3,h4,h5", 
            extendPage: false, 
            highlightDefault: true, 
            highlightOnScroll: true,
            scrollTo: 80,
        });
    }
</script>

<script src="/js/util.js"></script>
<script src="/js/crypto-js.min.js"></script>
<script src="/js/mask.js"></script>

<script src="/js/localsearch.js"></script></body>
</html>