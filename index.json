[{"categories":["技术"],"contents":"本文从Git的底层出发，深入探索Git的底层数据对象、数据存储优化、数据远程传输和历史记录维护，以此理解Git的版本控制机制，在探索原理的基础上总结Git的常用命令和最佳工作实践。\n简介 Git是一个分布式版本控制系统。\n版本控制：记录文件内容变更，支持查阅特定版本修订情况 分布式：每个本地客户端都保存数据仓库的完整镜像 Linux缔造者Linus Torvalds在2005年开发出Git用于管理维护Linux内核开源项目，Git的目标是：\n速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 高效管理类似Linux内核一样的超大规模项目 从根本上讲，Git是一种基于快照的内容寻址文件系统/键值对数据库，并在此基础上提供一些版本控制的用户接口。\n概念 快照 Git通过快照（提交时的文件全部内容）记录修改，而不是基本文件+增量更新 校验和 Git在存储任何数据时都会通过SHA-1算法计算校验和，以此作为数据的唯一标识 将Git视为键值对存储系统时，键即为：SHA-1校验和，值即为：数据 文件状态与工作区域 Git所管理的文件可能处于三种状态之一： 已修改 Modified：修改文件，但未保存到数据库 已暂存 Staged：对已修改文件的当前版本进行暂存，从而支持保存到数据库 已提交 Committed：文件已保存到数据库 每种状态对应Git的一种工作区域 工作目录 Working Directory 工作目录是对项目的某个版本独立提取出来的内容，使用者直接面向工作目录进行使用和更改 暂存区域 Staging Area / Index 暂存区域保存了将要提交的文件信息 Git仓库 .git directory Git仓库用来保存项目的元数据和对象数据库，包含项目的所有版本的数据 基本的Git工作流程是 在工作目录中修改文件 暂存文件，将文件快照放入暂存区域（概念上，实际上暂存区域存放文件索引/指针） 提交更新，找到暂存区域文件，将快照永久存储到Git仓库 工作目录中可以存在不由Git管理的文件，即：未跟踪Untracked的文件，可以将此类文件名称pattern放到.gitignore文件中，用来显式告知Git：此类文件不纳入版本控制也无需显式指出Untracked状态 分支 分支代表一条独立的开发线，通过分支可以使开发者从开发主线分离开来，在不影响主线的同时继续开发和提交 Git中分支实际上是指向更改快照的指针 标签 Git可以给历史中的某一个提交打上标签，用来指明这个提交版本的功能/特性 Git中主要有两种标签 轻量标签lightweight 只是一个特定提交的引用 附注标签annotated 存储到Git仓库的一个完整对象，包含打标签者的名字、邮件、日期时间和标签信息， 并可使用GNU Privacy Guard（GPG）签名与验证 远程仓库 远程仓库是指项目托管在Internet或其他网络中的项目的版本库 author\u0026amp;committer 原理 Git本质是一个内容寻址文件系统，其核心部分是一个键值对数据库，Git使用文件的SHA-1哈希值（160bit/40hex）作为key，文件快照作为value，提交、分支、标签等都是对key的组合和引用。\nGit对象 数据对象 Blob Object：保存文件内容\nblob对象类似UNIX中的inode，存储数据内容，即项目中的文件的内容 每当将文件加入暂存区时，Git会将文件快照（当前全部数据）保存到一个blob对象（逻辑上，实际可能会存在pack优化） blob对象的键是文件内容的SHA-1哈希值，值为文件内容，如果两个文件的内容相同则在Git中也仅会保存一个blob对象 blob对象物理上保存在.git/objects/目录中，具体保存路径是：.git/objects/ab/x...y，其中ab是blob键（即SHA-1哈希值）的前两个hex字符，x...y是blob键的剩余38个hex字符，保存格式为二进制（zlib压缩） 可通过git hash-object \u0026lt;file\u0026gt;命令根据传入的文件内容获取其blob对象的键（即文件内容的SHA-1哈希值），-w选项可同时保存此blob对象到Git仓库 可通过git cat-file -p \u0026lt;sha1\u0026gt;命令查看此对象的内容 可通过git cat-file -t \u0026lt;sha1\u0026gt;命令查看此对象的类型（blob/tree/commit） 树对象 Tree Object：保存文件名和文件组织层次\ntree对象类似UNIX中的目录，将多个文件和子目录组织起来，其包含了一条或多条tree entry，每个entry含有一个指向blob对象或者tree对象的SHA-1指针，以及相应的模式、类型、文件名信息\n每当暂存区变化后，Git根据当前时刻暂存区的状态创建并保存一个相应的tree对象；暂存区中实际上仅会保存文件，不会保存目录，Git会根据文件的层次结构自动生成相应层次的tree对象\ntree对象和blob对象相同，物理上保存在.git/objects/目录中，具体保存路径是：.git/objects/ab/x...y，其中ab是tree键（即SHA-1哈希值）的前两个hex字符，x...y是tree键的剩余38个hex字符，保存格式为二进制\n提交对象 Commit Object：保存版本的时序关系和版本信息\ncommit对象在一个tree对象的基础上保存了一次提交的时间、作者、提交信息以及本提交的父提交对象（if exists）\ncommit对象的格式是：\n一个顶层tree对象的SHA-1哈希值，代表当前项目快照 父提交对象的SHA-1哈希值 作者信息：name email 时间戳 提交者信息：name email 时间戳 留空一行 提交信息 每当执行提交操作时，Git会在当前暂存区tree对象的基础上生成一个新的commit对象\ncommit对象和blob对象相同，物理上保存在.git/objects/目录中，具体保存路径是：.git/objects/ab/x...y，其中ab是tree键（即SHA-1哈希值）的前两个hex字符，x...y是tree键的剩余38个hex字符，保存格式为二进制\n标签对象 Tag Object\ntag对象类似一个commit对象，包含标签创建者信息、日期、标签注释信息以及一个指向commit对象的SHA-1哈希值 当创建附注标签时，会产生一个tag对象 tag对象和blob对象相同，物理上保存在.git/objects/目录中，具体保存路径是：.git/objects/ab/x...y，其中ab是tree键（即SHA-1哈希值）的前两个hex字符，x...y是tree键的剩余38个hex字符，保存格式为二进制 通用对象存储格式\n所有Git对象都遵循如下格式进行组织 对象类型+空格+数据载荷长度+零字节+数据载荷 Git将此格式数据进行SHA-1哈希，得到对象的key 最后，Git将此格式数据进行zlib压缩后保存到磁盘的某个文件，路径和文件名根据SHA-1哈希值生成 Git引用 通过SHA-1哈希值可以唯一定位到任一类型的Git对象；为了使用方便可以将SHA-1哈希值保存在特定的文件中，并给文件起一个简单的名字，以此来最终定位到Git对象，此类文件即为Git引用 references/refs，物理上保存在 .git/refs/目录中 在Git中，引用包括 分支 一个指向某一系列提交对象之首的引用，物理上保存在 .git/refs/heads/目录 例如：master分支的引用路径为 .git/refs/heads/master文件，内容是x...x，即此分支最新提交的SHA-1哈希值 可通过底层命令：git update-ref refs/heads/\u0026lt;branch\u0026gt; \u0026lt;sha1\u0026gt;来创建一个指向sha1的分支branch 标签 一个指向某个提交对象或某个标签对象的引用，物理上保存在 .git/refs/tags/目录 标签引用的格式/底层创建同分支 HEAD HEAD文件（路径是 .git/HEAD）是一个符号引用symbolic reference，指向目前所在的分支 具体而言，HEAD文件的内容类似：ref: refs/heads/master，即指向当前所处的分支/标签的引用 当执行commit命令时，Git会创建一个提交对象，并使用HEAD指向的引用所指向的SHA-1哈希值设置此提交对象的父提交哈希值，同时将此提交对象的哈希值更新到HEAD所指向的引用文件 可通过 git symbolic-ref HEAD refs/heads/test来更新HEAD引用 远程引用 当添加远程版本库并进行push操作后，Git会记录下push的远程分支的引用 具体路径是： .git/refs/remotes/\u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; 远程引用类似一个分支引用，但是远程引用只能通过push和pull命令进行更新，不能通过本地的commit命令进行更新，因此，即使可以checkout到某个远程分支引用，但HEAD引用也不会指向此远程引用 Git优化 正常情况下，每次文件发生变更时Git都会对文件完整快照生成一个独立的blob对象\n从时间效率上看，每个变更单独快照的机制可以快速的定位到某次提交的内容，而不必在base的基础上沿提交链路依次叠加 从空间效率上看，由于很多情况下每次变更规模都远小于不变规模，因此单独快照的机制会重复存储很多相同数据，造成空间的浪费 基于此，Git使用pack的方式节省空间提高效率\nloose对象：单独快照存储的Git对象\npack对象：通过pack的方式将不同Git对象的相同部分仅存储一次\npack机制将loose对象进行打包，生成一个pack文件和一个pack索引\npack文件：存储不同loose对象的非重复部分，对于重复部分，剩余对象可以通过offset+size的机制进行引用，而不必重复存储全部内容 pack索引：记录每个Git对象的SHA-1哈希值、Git对象类型、大小、在pack文件中的offset和size 一般情况下，最新版本完整保存全部数据内容，而历史版本通过offset+size的方式保存重复部分，因为大部分情况下都需要快速访问文件的最新版本 pack文件和索引物理上存储在 .git/objects/pack/目录中\n进行pack的时机\n版本库中有很多loose对象时，一般7000+ 版本库中有很多pack对象时，一般50+ 手动执行git gc命令时 向远程服务器执行推送时 可通过git verify-pack -v \u0026lt;path-to-pack.idx\u0026gt;的方式展示并验证pack索引内容\ngit gc命令是Git用来维护仓库，优化存取效率的命令。\ngc会将loose对象合并到pack gc会将多个pack对象合并到一个pack gc会将多个引用打包到单独的文件，即将 .git/refs/目录下的文件打包到 .git/packed-refs文件以提高访问效率 当更新引用时，Git会在.git/refs/目录生成新的引用文件，也不会修改和更新pack文件，因此在查找引用时，Git会首先查找.git/refs/目录，然后查找pack文件 gc会移除与任何提交都不相关的陈旧对象 gc内部调用 git reflog expire命令，默认将超过90天的reflog entry删除，同时默认将超过30天的从对应引用tip提交不可达的reflog entry删除 gc内部调用prune命令，此命令会将同时满足两个条件的对象彻底删除 寿命限制：对象必须创建了足够长的时间（默认配置2周） 不可达限制：不能通过Git仓库的任意对象访问到此对象 任意对象包括普通Git对象、引用、reflog等 Git远程引用 远程引用是指对远程仓库中分支/标签的引用，物理上存储在 .git/refs/remotes/目录中。\n当添加远程版本库后，Git会在 .git/config配置文件中添加该远程版本库的配置：名称、URL、用于fetch和push操作的引用规则refspec\n引用规则的格式为： [+]\u0026lt;src\u0026gt;:\u0026lt;dst\u0026gt;\n+：即使在不能fast-forward的情况下也要强制更新引用 src：源引用 dst：目的引用 可通过修改refspec的形式，自定义远程分支的位置、远程分支拉取到本地分支的位置、拉取哪些远程分支、推送哪些分支到远程分支；也可以通过git push/fetch origin \u0026lt;src\u0026gt;:\u0026lt;dst\u0026gt;的形式手动指定本次f/p操作\n可将src留空以删除远程版本库的dst\nGit传输 Git主要通过dumb协议和smart协议在本地仓库和远程仓库间传输数据。\ndumb协议简单，但效率低，而且不能从客户端向服务端推送数据。\nsmart协议更为高效，支持推送和获取，但需要在Git服务端运行进程进行协助和交互。\ndumb协议 dumb协议将Git项目视为简单的键值数据库，通过HTTP请求以此获取，此过程无需Git本身的协助\ndumb协议的具体过程是\nGit服务端通过git update-server-info命令在 .git/info/refs/目录中生成refs文件，其中包含Git仓库的所有引用（分支+标签）以及SHA-1哈希值\n客户端首先通过GET请求获取refs文件，然后依次根据SHA-1哈希值获取loose对象\n对于获取的loose对象，根据其中的SHA-1哈希值获取其他Git对象\n当无法获取loose对象时（返回404响应），请求pack目录下的索引文件，然后检查SHA-1哈希值是否在索引文件中，然后继续请求pack文件\n重复上述过程，直到链路上的所有SHA-1都获取了对应的Git对象\nsmart协议 smart协议需要在Git服务端运行进程和客户端进行交互，通过两组进程传输数据，smart协议仅传输需要交换的数据，而无需传输全部内容。\n上传数据 上传数据需要运行在客户端上的send-pack进程连接到服务端运行的receive-pack进程。\nSSH协议传输\n客户端运行send-pack进程，通过SSH连接服务器，然后通过SSH发送命令字符串以使服务端执行命令\ngit-receive-pack命令会为服务端拥有的每一个引用（分支/标签）发送一行响应\n响应格式：前四字节代表本行长度，然后是SHA-1哈希值，然后是引用名称 对于第一行，还会在原基础上包含服务端能力（如report-status等，以及客户端识别码） 对于最后一行，为0000 此时客户端已经明确了服务端的状态，此时send-pack进程会判断哪些提交对象是客户端具有但服务端没有的\n如果服务端的引用的SHA-1值在本地不存在，则说明无法通过fast-forward的方式推送到远程分支 如果服务端的引用的SHA-1值在本地存在，则可以定位出在远程引用之后进行的所有本地提交 接下来客户端会为本次推送将会更新的各个引用向服务端发送一行请求\n请求格式：前四字节代表本行长度，然后是旧SHA-1值，然后是新SHA-1值，然后是要更新的引用名称 新增引用时，旧SHA-1值为0；删除引用时，新SHA-1值为0 对于第一行，还会在原基础上增加客户端能力 对于最后一行，为0000 然后，客户端会发送一个pack文件，包含了所有服务端还没有的Git对象\n最后，服务端会以成功或失败响应\nHTTP/HTTPS协议传输\n首先，客户端通过GET请求传递命令，并接受响应（内容与格式同上）\n然后客户端发起请求，上传pack，并接收响应（内容与格式同上）\n下载数据 下载数据需要客户端的fetch-pack进程连接到服务端的upload-pack进程\nSSH协议\n客户端运行fetch-pack进程，通过SSH向服务端发送命令调用upload-pack进程\n服务端会为拥有的每个引用发送一行响应，响应格式同上\n服务端还会为HEAD引用发送响应，因此当客户端执行clone时会确认工作目录对应的提交 客户端会查看自己拥有的对象，并通过want响应需要的对象的SHA-1值，通过have响应已拥有的SHA-1值，通过done结束请求\n最后，服务端可以发送pack文件，包含客户端需要的所有Git对象\nHTTP/HTTPS协议\nHTTP/HTTPS协议也涉及两个请求响应\n请求响应的内容格式同上\nGit数据维护 数据恢复 在某些情况下，可能会失去某些提交的引用：如reset重置分支到之前某一提交，此时后续提交对象（包括包含的tree和blob对象）仍然存在于./git仓库中，但是无法通过引用定位到他们的SHA-1值，Git提供了reflog机制（同时也是命令）和fsck命令来展示历史提交对象的SHA-1值。\nreflog机制在每次更改引用（分支+标签+HEAD）时都会记录此时引用的SHA-1哈希值，由此可以使我们定位到之前指向的Git对象。\nGit会把引用的变更日志物理上保存在 .git/logs/目录中\ngit fsck命令会分析Git数据库的完整性，通过--full选项会显示出所有没有被其他对象指向的对象，由此可以找到丢失对象的SHA-1哈希值。\n在找到提交的SHA-1值后，可通过在此提交上建立分支的方式重新将此系列提交添加到Git控制体系中。\n数据移除 作为一个分布式版本控制系统，版本控制使得Git保存所有的完整的历史提交和文件，分布式则使得Git执行clone操作时也会下载整个项目的全部历史。在特殊情况下，如果误提交了一个大文件，那么即使后续提交中将其移除，那么每次clone操作仍会下载这个误提交的大文件，造成不必要的资源浪费，Git提供了一种修改历史提交的机制以删除历史提交中的某个对象。\n注意：此操作对提交历史的修改是破坏性的，它会从包含该大文件的最早的树对象开始重写每一次提交，如果其他committer已经基于原始提交进行开发和提交，则需要他们将自己的提交变基rebase到修改历史后的新提交中。\n一些查看Git仓库占用大小的命令\ngit gc命令以进行pack git count-objects -v命令得到各部分的详细大小 数据移除的具体步骤是\n找到大文件 执行git gc 后再执行git verify-check -v命令，然后根据输出的第三列（文件大小）进行排序从而找到大文件的SHA-1值 执行git rev-list --objects --all命令会列出所有提交的SHA-1、blob对象的SHA-1和其关联的文件路径，从中根据之前确认的SHA-1值找到文件名称 找到添加大文件的提交 执行git log --oneline --branches -- \u0026lt;filename\u0026gt;以找到所有改动文件的提交 修改此提交之后的所有提交来从历史中完全移除文件 执行git filter-branch --index-filter 'git rm --ignore-unmatch --cached \u0026lt;filename\u0026gt;' -- \u0026lt;commit-sha1\u0026gt;^..命令 filter-branch命令用来重写Git分支，并链式的修改所有提交 --index-filter \u0026lt;command\u0026gt;选项将提交checkout到index暂存区后执行command命令然后提交，不会将提交checkout到工作目录（相当于仅checkout SHA-1值而不checkout具体数据），因此command也只能修改暂存区中的SHA-1值而不能修改具体数据 -- \u0026lt;commit\u0026gt;^..选项会从commit开始修改而非从最初提交开始 移除任何包含指向旧提交的指针的文件 git filter-branch命令会在 .git/refs/original/目录下记录原始的引用SHA-1值 reflog机制也会在 .git/logs/目录中记录原始SHA-1值 因此，需要删除这两个文件，以移除任何包含指向旧提交的指针的文件 重新打包 执行git gc命令，此时pack文件不会再包含移除的大文件 注意：如果大文件的创建时间小于配置时间，则大文件仍然会以loose对象的形式存在于本地仓库中，但不会影响和参与到push/pull操作（详见上述git gc命令） 可选：在本地仓库彻底删除 通过git prune --expire now命令完全移除此大文件，即所有引用不可达的孤儿对象 Git Diff Git通过diff展示某次提交/暂存做了哪些改动，diff也是merge操作的基础。\ngit diff产生的输出格式如下：\ndiff --git a/txt b/txt表明实际调用的命令 index \u0026lt;old\u0026gt;..\u0026lt;new\u0026gt; mode表明比较的两个文件的sha-1值和文件模式 --- \u0026lt;old\u0026gt;表示旧文件 --- \u0026lt;new\u0026gt;表示新文件 @@ -3,7 +3,7表明旧文件发生diff的起始行,行数和新文件发生diff的起始行,行数 以下即为具体比较结果，-表示移除旧文件此行，+表示增加新文件此行 Git中diff支持两种算法Myers算法和Patience算法，默认采用Myers算法。\n从算法角度，diff对应的模型是：对于两个文本A和B，允许两种操作：插入、删除，求出操作数量最少（即编辑距离最短）的A转为B的操作序列。\nMyers算法 Myers算法由 Eugene W.Myers 在 1986 年发表在 《 Algorithmica》 杂志上的一篇论文中提出，是一个能在大部分情况产生最短的直观的diff 的一个算法，最短指编辑距离最短，直观指删除插入由于插入删除，整块代码删除新增优于交叉删除新增。\n算法内容可参考：https://cloud.tencent.com/developer/article/1724029\nPatience算法 Patience算法的作者是BitTorrent的作者Bram Cohen. 在他的博客上有一个简单的介绍( https://bramcohen.livejournal.com/73318.html , https://alfedenzo.livejournal.com/170301.html ).\npatience diff实际上不算是一种算法, 而是一种在对比两个文本时如何在应用diff算法(例如Myers)前, 将文本分为合理的小文本的手段. 做这种预先处理的原因是, Myers经常将一些无意义的行匹配起来, 例如空行和括号, 这会导致一些恼人的匹配结果以及导致合并冲突的结果. Patience diff 的改进是: 对两个文本都进行一次全扫描, 得到一组共有的, 在各自文本里都只出现了一次的行, 这将助于得到更有意义而不是生硬的内容划分。\nGit Merge/Rebase/Revert 合并是非线性工作流的基础操作，其核心是将不同分支的变更集成在一起。Git中主要有两种操作进行集成分支，merge和rebase。\nFast-Forward 当合并的两个分支存在线性亲缘关系时（即本分支是目标分支的祖先提交），从逻辑和实际角度，合并操作仅会将原分支指向目标分支，不产生任何比较、冲突情况。这种特殊情况的merge方式为快进fast-forward。\nThree-Way Merge 当合并的两个分支不存在线性亲缘关系时，合并策略是三路合并three-way merge。具体而言：\nthree-way base：两个分支的最近共同祖先提交的文件 ours：当前分支的文件 theirs：目标合并分支的文件 LCS 在确定三路文件后，通过算法找出三路文件的LCS/最长公共子序列 merge 三路文件根据LCS一一对应后 b/base和o/ours和t/theirs如果其中两者相同（包括两者都为空），则使用第三者作为输出 如果b和o和t都不相同，说明o和t修改了同样的区域，产生冲突 对于新增文件，通过文件名一一对应 如果b和o和t其中两者相同（包括两者不存在），则使用第三者作为输出 如果b和o和t都不相同，则产生冲突 Recursive Three-Way Merge 在一些特殊场景下，两个合并分支的最近共同祖先非唯一：\nrecursive three-way merge算法会首先合并两个最近共同祖先到一个虚拟节点，然后选定虚拟节点为base分支进行三路合并，在合并两个最近共同祖先时，仍然采用recursive three-way merge算法，因此此算法称为recursive。\nMulti-Way Merge 在合并多个分支时，三路归并算法会产生多个中间节点，造成提交记录拓扑的混乱，mutil-way merge会逐步采用三路归并算法，同时不在最终提交记录中保持中间节点。\nMerge Strategy git merge -s \u0026lt;strategy\u0026gt;可以选定strategy合并策略\nresolve策略对应three-way merge算法，如果存在两个最近共同祖先时，resolve策略自动选择其中在它看来最优的一个作为base，同时不会检测文件重命名操作，即如果两个分支分别重命名源文件到不同名称文件时，resolve策略会视为两个分支同时删除源文件，分别新增新的不同的文件，因此不会产生合并冲突 recursive策略对应recursive three-way merge算法，同时recursive策略会检测文件重命名操作，因此如果两个分支同时重命名源文件到不同名称文件时，recursive策略会产生合并冲突 ort策略和recursive策略采用的算法和对应输出相同，但是ort策略重构了recursive策略的代码，效率更高、速度更快 octopus策略对应multi-way merge算法，当merge命令同时合并多个分支时使用此策略 Git Apply apply机制是合并不同分支变更的另一种实现方式。本质上，apply是指对另一分支在本分支之外的所有提交产生一个补丁/patch，然后依次将每个patch应用到本分支。\npatch中包含了变更的上下文和变更本身，git通过patch context（变更上下文）定位到变更位置，然后应用具体变更，因此会存在一些特殊case导致变更应用到错误的位置（比如根据patch上下文可以定位到多个位置，又比如当前分支新增内容也符合patch上下文）\nGit Rebase git rebase命令是Git向用户提供的合并不同变更的另一个顶层命令。\n从逻辑上讲，rebase命令将分支A相对于分支B的所有提交保存成patch文件，然后将patch文件依次应用到分支B。因此从提交记录拓扑图上，rebase命令在分支B上新进行了多个patch提交，然后将分支A引用指向最终提交，是一个线性的拓扑图。\n从实现上讲，rebase命令实际存在两种实现方式\nmerge方式：对于分支A相对于分支B的每个提交C，执行一次merge操作 base：提交C的直接父提交（注意：不是最近共同祖先提交） ours：分支B的顶层提交 theirs：提交C 默认情况下，或者通过 -i选项指定时，都采用此方式 底层实现上，此方式相当于对每个提交C执行 git cherry-pick C apply方式：对于分支A相对于分支B的每个提交C，生成patch文件然后依次应用到分支B 通过 --apply选项可以指定此方式 注意：分支A相对于分支B的每个提交，即分支A中从分支AB的最近共同祖先开始的每个提交\n注意：git rebase命令会忽略分支A中新增的merge提交，因为逻辑上已经新增了merge提交的每个变更，因此无需再次考虑merge提交。\n这种情况下，由于rebase实际上忽略了merge提交时可能的冲突解决变更，因此可能会出现通过rebase和merge命令合并分支时，rebase产生合并冲突，merge不产生合并冲突。 Git Revert git cherry-pick命令用来撤销某个提交所进行的变更，是revert命令的完全逆操作，逻辑上，cherry-pick对当前分支应用父提交到子提价的修改，revert对当前分支应用子提交到父提交的修改；实现上，cherry-pick和revert都采用recursive three-way merge算法，只不过两者的base和theirs相反。\n对于git revert命令，对于当前分支A，待撤销提交C：\nbase：C ours：A theirs：C的直接父提交 Git目录 每个由Git管理的项目都会有一个对应的.git隐藏目录用来保存Git存储和操作的所有对象（概念上包括项目的所有版本和暂存区），.git目录中包含如下文件\nHEAD 指向当前所处的分支 config 保存项目特有的配置选项 description 项目描述信息，用于GitWeb程序使用 COMMIT_EDITMSG 保存最新一次提交的日志信息 index 暂存区，实际存储指向每个对象的指针（SHA-1值） 可用git ls-files -s命令查看暂存区的文件信息 hooks/ 保存Git特定动作时触发的自定义脚本，分为客户端hook和服务器hook info/ 保存git仓库的一些额外本地信息，主要包括 exclude文件，作用与 .gitignore文件相同，但不会纳入Git版本控制（checkout时也不会变动），因此可用于只应用于本地的排除操作 attributes文件，作用与 .gitattributes文件相同 针对特定文件配置特定属性，用于单独定义文件属性/合并策略/diff等 objects/ 保存所有的Git对象（blob+tree+commit+tag） 进行pack操作后，同时保存pack文件和索引 refs/ 保存每个引用指向的Git对象的SHA-1值 内部包括heads/：保存本地分支；tags/：保存标签，remotes/：保存远程分支 logs/ 保存每个引用（HEAD+分支）的变更记录，供reflog查询 内部结构类似于refs/目录 使用 选择符 如前所述，Git本质上是一个键值对存储系统，可以通过SHA-1值定位对应的Git对象。Git也支持其他方式来指定某个或某些提交对象。\n单一提交 SHA-1 提交对象的完整SHA-1值 提交对象的简短SHA-1值，至少4位，同时保证无歧义 SHA-1是所有定位方法的本质 引用 HEAD：定位当前所处的提交 分支：通过分支名称定位到分支的最新提交 标签：通过标签名定位到标签对应的提交 reflog \u0026lt;ref\u0026gt;@{\u0026lt;n\u0026gt;} 含义：引用ref倒数第n次所处的提交 实例： HEAD@{0}：等价于HEAD \u0026lt;ref\u0026gt;@{time} 含义：引用ref在时间time时指向的提交 实例： HEAD@{1.hours.ago}：1小时前HEAD所处的最后的提交 原理：通过reflog机制（.git/logs/）实现，因此一旦reflog删除/过期，则无法定位 祖先引用 定位符 ^ 格式：\u0026lt;selector\u0026gt;^[\u0026lt;n\u0026gt;] 含义：选择符selector提交的第n父提交（均为selector的直接父提交） 注意：^的个数代表倒数第几代，n代表同一代中第几个父提交，可交替使用，n默认为1 实例： HEAD^^：HEAD的第一父提交的第一父提交 HEAD^2：HEAD的第二父提交（当且仅当HEAD由merge得到，此选择符返回merge的第二个对象） d9214^^^3：提交d9214的第一父提交的第一父提交的第三父提交 master^1^^2：master分支当前引用的第一父提交的第一父提交的第二父提交 定位符 ~ 格式：\u0026lt;selector\u0026gt;~[\u0026lt;n\u0026gt;] 含义：选择符selector提交的倒数第n代的第一父提交，默认n为1，即直接父提交 实例： HEAD~2：HEAD的第一祖父提交，等价于：HEAD~~等价于 HEAD^^ 上述两个定位符可连用 HEAD~2^2：HEAD的第一祖父提交的第二父提交（第二曾祖父提交） 助记 ~：是近似线性连续的，表明一个直接的线性历史，因此数字表示代数 ^：是两条线合并到一点，表明分支合并结构，因此数字代表合并的同一代的第几个父提交 提交区间 双点 格式：\u0026lt;refA\u0026gt;..\u0026lt;refB\u0026gt; 含义：在refB分支而不在refA分支的全部提交 助记：refA+..=refB，因此表示在refA之外的提交 实例：git log origin/master..HEAD 列出当前分支中还未推送到远程master分支的所有提交 排除 格式：\u0026lt;refA\u0026gt; \u0026lt;refB\u0026gt; ^\u0026lt;refC\u0026gt; 格式：\u0026lt;refA\u0026gt; \u0026lt;refB\u0026gt; --not \u0026lt;refC\u0026gt; 含义：被refA或refB包含但不被refC包含的所有提交，可多个分支一起使用 实例： refB ^refA等价于 refA..refB 三点 格式：\u0026lt;refA\u0026gt;...\u0026lt;refB\u0026gt; 含义：被refA或refB包含但不被同时包含的所有提交 实例：git log --left-right master...feat 列出仅被master或仅被feat包含的提交 --left-right选项使得仅被master包含的提交前带有小于号，否则带有大于号 配置 git config git config [--system|---global|---local] [--add|--get|--unset] [--show-origin] [--list] \u0026lt;name\u0026gt; [value] 作用\n查看/变更Git配置 选项\n--system：配置面向系统内全部用户生效，即修改在 /etc/.gitconfig or /etc/git/config文件中 --global：配置面向当前用户生效，即修改在 ~/.gitconfig or ~/git/config文件中 --local：配置面向此git项目生效，即修改在 .git/config文件，默认local，生效顺序优先级最高 --add：在name配置的基础上新增value，不加add时默认情况下替换value --get：获取name的配置（首次匹配），--get-all获取全部作用域全部匹配的配置 --unset：删除name的配置（首次匹配），--unset-all删除全部作用域全部匹配配置 --show-origin：展示配置来源目录 --list：获取全部配置，与配置范围联用 name：配置名称，单独使用时展示name的值 value：配置值 实例\ngit config --global user.name 'Bryce' 配置用户名称（用于提交对象中的作者信息） git config --global alias.cmm 'commit -m' 配置命令Git别名 创建 git init git init [name] 作用 创建Git项目 选项 默认情况下在当前目录创建git项目，即创建 .git/目录 name：创建name目录为Git项目，即创建 name/.git/目录 git clone git clone [--single-branch] [--branch | -b] \u0026lt;branchname\u0026gt; \u0026lt;url\u0026gt; [name] 作用 将url指向的远程仓库克隆到本地，默认情况下包括全部分支/标签/HEAD，同时在本地创建对应的远程分支引用，最后将HEAD引用的分支的提交checkout到工作目录。 选项 --single-branch：只克隆单一分支的提交历史数据，默认情况下是远程仓库的HEAD指向的分支 -b：克隆完成后checkout到branchname分支 url：远程仓库url，可以是ssh协议或http(s)协议连接 name：克隆至目录name 实例 git clone --single-branch -b dev git@github.com:U/blog.git 变更 git add git add [--dry-run | -n] [--update | -u] [--force | -f] [--all | -A] \u0026lt;pathspec\u0026gt;... 作用 将工作目录中的变更（文件新增/修改/删除）添加到暂存区域/index 选项 -n：不实际添加，只输出将要进行的操作 -u：只处理已经track（已经存在于index）的文件 -f：强制添加，跳过 .gitignore文件的限制 -A：处理全部文件的新增/修改/删除，旧版本(git 1.x)默认情况下不会处理文件删除（即如果index中存在文件A，同时在工作目录删除A，则add不会在index中删除A），高版本默认处理文件删除，即 git add .等价于 git add --all pathspec：所要处理的文件名称规则，支持通配符，支持多个 实例 git add . 添加当前目录的所有变更到暂存区 git add dir/\\*.c 添加dir目录及其子目录中所有c文件变更到暂存区 git rm git rm [--dry-run | -n] [--force | -f] [--cached] [-r] [--] \u0026lt;pathspec\u0026gt;... 作用 从暂存区和工作目录中删除文件 选项 -n：不实际删除，只输出将要进行的操作 -f：强制删除，默认情况下，rm的文件要求必须未经过修改（即HEAD中的文件内容与index中的文件内容与工作目录中的文件内容相同），通过此选项可以强制删除(暂存区和工作目录) --cached：仅在暂存区域中删除文件，保留工作目录中的文件 -r：对pathspec指定的目录递归执行 --：作为命令和文件名称的分隔符，以避免文件名被视为命令选项 pathspec：要删除的文件名称规则 实例 git rm -r d 递归删除目录d git mv git mv [--dry-run | -n] [--force | -f] [-k] \u0026lt;source\u0026gt;... \u0026lt;destination\u0026gt; 作用 移动或者重命名文件 选项 -n：空运行 -k：出错时跳过 -f：强制执行，即使目标文件名已存在 source：源文件名称，可多个 destination：目标文件名称，可为目录，可不存在 实例 git mv t1 t2 d 将文件t1、t2移动到目录d git restore git restore [--source=\u0026lt;tree\u0026gt; | -s \u0026lt;tree\u0026gt;] [--worktree | -W] [--staged | -S] [--ours] [--theirs] [--merge | -m] [--] \u0026lt;pathspec\u0026gt;... 作用 撤销/还原工作目录的修改，默认情况下将工作目录还原到暂存区状态 选项 -s：源对象（要把文件还原/恢复到源对象） 指定 -W选项时，默认source为index，即将工作目录的修改还原到暂存内容index 指定 -S选项时，默认source为HEAD，即将暂存区还原到HEAD 也可以指定其他提交ID -W：执行还原操作的对象为工作目录，即把工作目录还原到index，默认此选项 原理：将INDEX拷贝复原到WD -S：执行还原操作的对象为暂存区域，即把index还原到HEAD 原理：将COMMIT(默认INDEX)拷贝复原到INDEX --ours：当要还原出现合并冲突的文件时，ours选项表明将冲突文件还原到当前分支 --theirs：当要还原出现合并冲突的文件时，theirs选项表明将冲突文件还原到合并目标分支 --merge：表明重新将文件还原到合并冲突的状态 --：分隔命令选项和文件名称，表明后续全为文件名称 pathspec：文件名称，可多个 实例 git restore -s HEAD^ -WS . 将工作目录和暂存区的修改都撤销，还原到HEAD前一个提交 git restore --ours txt 将合并冲突的txt还原到我方分支内容 备注 git 2.23版本新增，用于拆解checkout命令的功能 git checkout git checkout [\u0026lt;tree\u0026gt;] [--ours] [--theirs] [--merge | -m] [--] \u0026lt;pathspec\u0026gt;... 作用 此形式下用于撤销/还原工作目录修改，默认情况下将工作目录还原到暂存区状态 原理 默认情况下：将INDEX拷贝复原到WD 指定tree时：将COMMIT拷贝复原到INDEX，然后将INDEX拷贝复原到WD 选项 tree：要还原到的源对象（默认情况下为index） --ours：当要还原出现合并冲突的文件时，ours选项表明将冲突文件还原到当前分支 --theirs：当要还原出现合并冲突的文件时，theirs选项表明将冲突文件还原到合并目标分支 --merge：表明重新将文件还原到合并冲突的状态 --：分隔命令选项和文件名称，表明后续全为文件名称 pathspec：文件名称，可多个，必选 实例 git checkout HEAD -- . 将当前暂存区和工作目录全部还原到HEAD 备注 这是checkout用于撤销/还原工作目录的功能用法 此形式中必须指定pathspec git reset git reset [\u0026lt;tree\u0026gt;] [--] \u0026lt;pathspec\u0026gt;... 作用 此形式下用于还原暂存区INDEX到指定的TREE，而不会修改工作目录，默认情况下TREE为HEAD 选项 tree：源提交 --：分隔命令选项和文件名称，表明后续全为文件名称 pathspec：文件名称，可多个，必选 实例 git reset . 将此时暂存区IDNEX还原到HEAD 备注 此形式下reset用于还原INDEX 此形式下pathspec必选 git revert git revert [--no-commit | -n] \u0026lt;commit\u0026gt;... git revert (--continue | --skip | --abort | --quit) 作用 通过生成新提交的方式撤销某个指定的提交 选项 --n：撤销指定的提交，只将撤销操作应用到INDEX和WD，而不生成新提交 commit：指定的提交，可多个，必选 git clean git clean [--dry-run | -n] [--force | -f] [--interactive | -i] [-d] [-e \u0026lt;pattern\u0026gt;] [-x] [-X] [\u0026lt;path\u0026gt;...] 作用 从工作目录中移除未跟踪文件/untracked files（未添加到暂存区域index的文件），默认情况下不会移除未跟踪目录（如果未指定path）、不会移除 .gitignore指定忽略的文件 选项 -n：试运行，输出将要清除的文件 -f：如果git配置中 clean.requireForce变量没有设置为false(默认为true)，则只有带有此选项才能真正删除 `-i：交互式执行clean -d：移除未跟踪目录 -e：增加忽略规则，命中规则的文件不会清除 -x：同时移除命中 .gitignore文件中规则的文件 -X：仅移除命中 .gitignore文件中规则的文件 path：指定清除的文件规则，可多个，可选，为空时为当前目录 实例 git clean -f . 移除当前目录中的未跟踪文件，不包括命中.gitignore的文件，包括未跟踪目录 git stash git stash push [--keep-index | -k] [--all | -a] [--message | -m] [--] [\u0026lt;pathspec\u0026gt;...] list show [-p] [\u0026lt;stash\u0026gt;] pop [--index] [\u0026lt;stash\u0026gt;] apply [--index] [\u0026lt;stash\u0026gt;] branch \u0026lt;branchname\u0026gt; [\u0026lt;stash\u0026gt;] clear drop [\u0026lt;stash\u0026gt;] 作用 将目前已经修改但不想提交的内容（工作目录和暂存区）保存到堆栈区，使工作目录和暂存区恢复clean状态，后续可根据需要在某个分支/时刻恢复出堆栈区的内容 原理 stash命令push的过程实际上是对此时的暂存区和工作区分别创建一个提交，同时通过 .git/refs/stash引用最新一个stash的提交，之前进行过的stash创建的提交对象通过stash引用的reflog来进行定位 stash命令pop的过程实际上就是对stash引用的提交和当前工作目录执行一个合并操作 选项 push 保存工作目录和暂存区到stash -k：不stash暂存区，只stash工作目录，仍然保留暂存区状态 -a：所有忽略和未跟踪的文件都会加入到stash提交中，然后执行clean -m：对本次stash的说明 pathspec：只对命中path的文件进行stash和还原，可多个，可选 list 展示全部stash的提交，可使用log命令的相关选项 show 展示某个stash提交的变更diff（stash提交与进行stash操作时所在HEAD的提交的diff，而非stash提交与当前工作目录的diff） -p：展示具体diff 同时可使用diff命令的相关选项 pop 应用并弹出某个stash提交，默认情况下应用弹出最新一次stash提交 --index：同时恢复stash的暂存区的提交到当前暂存区，默认情况下仅恢复工作目录 apply 应用某个stash提交，但不弹出 drop 移除某个stash提交 clear 清空全部stash提交 branch 在进行stash的提交处新建一个分支，然后把stash提交应用到此分支 实例 git stash push -m \u0026quot;func\u0026quot; 将当前工作区和暂存区进行stash git show -p stash^ 查看前一个stash提价的diff git status git status [--short] [--verbose | -v] [-vv] [--] [\u0026lt;pathspec\u0026gt;...] 作用 展示当前HEAD、INDEX、WD三者之间的区别 选项 --short：通过短形式展示 绿色：HEAD和INDEX之间的区别 红色：INDEX和WD之间的区别 A：新增文件 D：删除文件 M：修改文件 R：重命名 U：合并冲突 T：文件类型改变 ?：文件未跟踪 !：文件已忽略 -v：同时展示HEAD和INDEX的diff -vv：同时展示HEAD和INDEX的diff，以及INDEX和WD的diff --：分隔命令选项和文件名称，表明后续全为文件名称 pathspec：文件名称，可多个，必选 git diff git diff [--cached] [\u0026lt;commit\u0026gt;] [\u0026lt;commitA\u0026gt; \u0026lt;commitB\u0026gt;] [--] [\u0026lt;path\u0026gt;...] 作用\n输出不同提交之间的diff，默认情况下输出INDEX到WD的diff 选项\n--cached：输出HEAD到INDEX的diff commit：输出COMMIT到WD（或者INDEX）的diff commitA commitB：输出commitA到commitB的diff --：分隔命令选项和文件名称，表明后续全为文件名称 path：文件名称，可多个，必选 实例\ngit diff --cached HEAD^\n输出HEAD^到INDEX的diff git diff\n输出INDEX到WD的diff git commit git commit [--dry-run] [--all | -a] [--amend] [-m \u0026lt;msg\u0026gt; | --message=\u0026lt;msg\u0026gt;] [--] [\u0026lt;pathspec\u0026gt;...] 作用 将INDEX中的内容进行提交 将INDEX打包成COMMIT对象，其中当前HEAD为此COMMIT的父提交对象，然后将此提交加到HEAD指向的分支顶部 选项 --dry-run：试运行，只输出变更的文件 -a：自动将已跟踪文件中进行变更/删除的文件加到暂存区然后进行提交，但不会添加未跟踪文件 --amend：在当前提交的前一提交的基础上创建一个新提交，保存当前提交的修改和最新修改，然后将HEAD指向新提交 -m：指定提交信息 --：分隔命令选项和文件名称，表明后续全为文件名称 pathspec：文件名称，可多个，可选，用来指定本次提交包含的文件 git tag git tag [--annotate | -a] [--force | -f] [--delete | -d] [--message=\u0026lt;msg\u0026gt; | -m \u0026lt;msg\u0026gt;] [--file=\u0026lt;file\u0026gt; | -F \u0026lt;file\u0026gt;] [-v] \u0026lt;tagname\u0026gt; [\u0026lt;commit\u0026gt;] 作用 创建/展示/删除tag 选项 -a：创建附注标签 -f：替换tag -d：删除tag -m：tag信息，用于附注标签 -F：文件内容作为tag信息，用于附注标签 -v：显示tag内容 tagname：标签名称 commit：指定对某个提交创建tag，可选，默认为HEAD 实例 git tag -a -m \u0026quot;tag: 1.0\u0026quot; v1.0 创建附注标签v1.0 分支 git branch git branch [--list | -l] [--verbose | -v] [--remotes | -r] [-all | -a] git branch [-f] \u0026lt;branchname\u0026gt; [\u0026lt;commit\u0026gt;] git branch (--set-upstream-to=\u0026lt;upstream\u0026gt; | -u \u0026lt;upstream\u0026gt;) [\u0026lt;branchname\u0026gt;] git branch --unset-upstream [\u0026lt;branchname\u0026gt;] git branch [-m | -M] [-c | -C] [\u0026lt;oldbranch\u0026gt;] \u0026lt;newbranch\u0026gt; git branch (-d | -D) [-r] \u0026lt;branchname\u0026gt;... 作用 查看、创建、变更Git分支 选项 -l：查看本地分支 -r：查看本地保存的远程分支 -a：查看本地分支和远程分支 -v：展示分支的详细信息，包括最新提交 -f：强制创建/更改，即使分支已存在 branchname：分支名称 commit：分支引用的提交 -u：设置分支的远程跟踪分支，用于拉取合并 --unset-upstream：移除分支的远程跟踪分支 -m：分支重命名，默认当前分支 -M：分支强制重命名，即使新分支已存在，即 -m -f -c：分支复制，默认当前分支 -C：分支强制复制，即使新分支已存在，即 -c -f -d：分支删除，可多个，与 -r连用可删除本地保存的远程分支 -D：分支强制删除 实例 git branch -d -r origin/todo 删除远程分支todo，注意如果没有显示配置，则下次执行pull或fetch命令时仍然会创建对应的远程分支 git switch git switch [-c | -C] [--merge | -m] \u0026lt;branch\u0026gt; [\u0026lt;commit\u0026gt;] git switch --detach [\u0026lt;commit\u0026gt;] 作用 切换分支 选项 -c：创建分支，初始指向commit，默认为HEAD -C：强制创建分支，即使分支已存在 -m：切换分支时进行三方合并（HEAD+WD+BRANCH） --detach：切换到commit，不创建新分支，HEAD直接指向commit而不是指向引用 实例 git switch - 切换到上次所在分支 git switch dev 切换到dev分支，如果dev分支不存在，但是存在远程同名分支（例如 origin/dev），则会基于此远程分支自动创建分支dev，同时设置两者的跟踪关系 git checkout git checkout [--detach] [--merge | -m] [-b | -B] [--orphan] \u0026lt;branch\u0026gt; [\u0026lt;commit\u0026gt;] 作用 切换分支 选项 -b：创建分支，初始指向commit，默认为HEAD -B：强制创建分支，即使分支已存在 -m：切换分支时进行三方合并（HEAD+WD+BRANCH） --detach：切换到commit，不创建新分支，HEAD直接指向commit而不是指向引用 --orphan：创建孤儿分支，即分支不包括任何提交，但包括commit的暂存区和工作目录 git reset git reset [--soft | --mixed | --hard] \u0026lt;commit\u0026gt; 作用 重置HEAD到指定状态 原理 reset命令不指定特定文件时的一般过程是 移动HEAD指向分支的指向（注意不是直接改变HEAD，而是改变HEAD指向分支） 复制此时HEAD到INDEX 复制INDEX到WD 选项 --soft：只进行第一步，即改变HEAD指向分支的顶部提交为commit，同时不改变当前的INDEX和WD --mixed：进行第一步第二步，默认情况 --hard：进行第一步第二步第三步 git merge git merge [--no-commit | --commit] [--ff | --no-ff | --ff-only] [-s \u0026lt;strategy\u0026gt; | --strategy=\u0026lt;strategy\u0026gt;] [-m \u0026lt;msg\u0026gt; | --message=\u0026lt;msg\u0026gt;] [\u0026lt;commit\u0026gt;...] git merge [--continue | --quit | --abort] 作用 在当前分支合并参数分支的修改 选项 --no-commit：合并分支，但不进行提交，用于检查修改，默认是 --commit，即创建提交 -ff：如果当前分支和参数分支存在亲代关系，则直接通过移动指针的方式进行合并，不创建新提交，--no-ff会创建一个新提交（尽管提交的内筒仍然是最新提交的内容） -s：指定合并策略，默认为 ort -m：合并信息 commit：要合并的提交，可多个，可选，为空时默认合并当前分支的远程跟踪分支 git rebase git rebase [-i | --interactive] [--exec \u0026lt;cmd\u0026gt;] [--apply | --merge] [--onto \u0026lt;base\u0026gt;] [\u0026lt;start\u0026gt; [\u0026lt;end\u0026gt;]] git rebase [--continue | --skip | -abort | --quit] 作用\n将部分提交所作的修改重新应用到指定的基准提交 具体而言，将start到end的左闭右开范围提交（即 \u0026lt;start\u0026gt;..\u0026lt;end\u0026gt;，即 \u0026lt;end\u0026gt;提交链中除去 \u0026lt;start\u0026gt;提交链的部分）重新应用到base，未指定base时，默认base为start，未指定end时，end为HEAD，未指定start时，start为HEAD的远程跟踪分支（对应配置项中的branch.\u0026lt;name\u0026gt;.remote \u0026amp;\u0026amp; branch.\u0026lt;name\u0026gt;.merge） 选项\n-i：交互式进行rebase，即将\u0026lt;start\u0026gt;..\u0026lt;end\u0026gt;的每个提交手动进行处理，支持若干动词\n--exec：在应用每个commit后，通过shell执行cmd命令\n--apply：指定通过提取patch然后apply的方式进行变基\n--merge：指定通过三路合并的merge方式进行变基，默认方式\n--onto：手动指定base，默认为start\n交互-动词\n具体方式是： 命令面板自上而下是start到end的左闭右开范围提交（即 \u0026lt;start\u0026gt;..\u0026lt;end\u0026gt;） rebase命令会自上而下应用每个提交到base，同时更新base pick：不作处理，直接采用此提交 reword：采用提交，但弹出编辑面板用于编辑提交信息 edit：采用提交，然后停止，通过执行 git commit --amend命名增补此提交，然后执行 git rebase --continue继续 squash：采用提交，但把此提交压缩到上一个提交（即此时的HEAD不移动），弹出编辑面板用于编辑提交信息 fixup：默认仅保留上一提交信息，指定 -C时仅保留选项中的commit的提交信息 exec：通过shell运行命令 break：暂停 drop：舍弃此提交 实例\ngit rebase 将HEAD在 \u0026lt;origin\u0026gt;/\u0026lt;branch\u0026gt;之外的提交重新应用/变基到 \u0026lt;origin\u0026gt;/\u0026lt;branch\u0026gt; git rebase master 将HEAD在master之外的提交重新应用/变基到master git rebase master featA 将featA在master之外的提交重新应用/变基到master，同时自动切换到featA git rebase --onto master featA featAB 将featAB在featA之外的提交重新应用/变基到master git rebase -i HEAD~3 将HEAD在HEAD~3之外的提交重新应用/变基在HEAD~3，同时通过交互的方式处理每个提交 重写 HEAD~2 HEAD~1 HEAD三个提交 历史 git log git log [\u0026lt;options\u0026gt;] [\u0026lt;revision-range\u0026gt;] [[--] \u0026lt;path\u0026gt;...] 作用 查看某个提交/引用/范围的提交日志 具体：以options格式展示 revision-range提交范围中对 path...文件进行变更的所有提交 revision-range：给定单提交时为该提交的提交链，为空时为HEAD的提交链 实例 git log --oneline master -- h.cpp 通过oneline格式展示master提交链中对 h.cpp进行变更的所有提交 git reflog git reflog [show] [\u0026lt;log-options\u0026gt;] [\u0026lt;ref\u0026gt;] git reflog expire [--expire=\u0026lt;time\u0026gt;] [--expire-unreachable=\u0026lt;time\u0026gt;] [--rewrite] [--updateref] [--stale-fix] [--dry-run | -n] [--verbose] [--all [--single-worktree] | \u0026lt;refs\u0026gt;...] git reflog delete [--rewrite] [--updateref] [--dry-run | -n] [--verbose] \u0026lt;ref\u0026gt;@{\u0026lt;specifier\u0026gt;}... git reflog exists \u0026lt;ref\u0026gt; 作用 管理每个引用的reflog信息 选项 show：展示某个引用的reflog，接受log的所有选项同时遵循其格式，默认展示HEAD引用 expire：删除已经过期的reflog delete：删除某个reflog的单个entry exists：查看某个引用是否有reflog 实例 git reflog 查看HEAD的reflog git reflog featA -- 查看featA的reflog，后续 --必选，因为此命令接受log格式，必须通过 --来划分引用名和文件名 git show git show [\u0026lt;options\u0026gt;] [\u0026lt;object\u0026gt;...] 作用 展示各种类型的Git对象 类型 commit 展示提交对象的提交信息以及文本diff tag 展示tag对象的标签信息和引用的提交对象 tree 展示tree对象的名称 blob 展示blob对象的内容 实例 git show HEAD 展示HEAD引用提交的信息和diff git describe git describe [--all] [--tags] [--contains] \u0026lt;commit\u0026gt; 作用 为commit返回一个可读性高的版本名称 默认情况下，找到commit亲代中最近的附注tag，然后根据标签名称、代际数、当前提交sha-1生成可读的提交名称 选项 --all：在所有的引用中查找 --tags：在所有的tags中查找，包括轻量级标签和附注标签 --contains：在commit的子代中找最近的tag git blame git blame [-L \u0026lt;range\u0026gt;] [--] \u0026lt;file\u0026gt; 作用 追溯一个指定文件的历史修改记录，展示哪个author对文件的每一行做了什么修改 选项 -L：指定范围 \u0026lt;start\u0026gt;,\u0026lt;end\u0026gt;：start到end行 \u0026lt;start\u0026gt;,+\u0026lt;offset\u0026gt;：start到start+offset行 \u0026lt;start\u0026gt;,/regex/：start到匹配 /regex/行 实例 git blame -L '/^sub hello {/,/^}$/' foo 追溯从 sub hello {到 }的行的历史修改记录 远程 git remote git remote add \u0026lt;name\u0026gt; \u0026lt;URL\u0026gt; git remote rename \u0026lt;old\u0026gt; \u0026lt;new\u0026gt; git remote remove \u0026lt;name\u0026gt; 作用 管理远程仓库 git fetch git fetch [--all] [--set-upstream] [\u0026lt;repository\u0026gt;] [\u0026lt;refspec\u0026gt;...] 作用 从远程仓库下载对象和引用 refspec 引用规则的格式为： [+]\u0026lt;src\u0026gt;:\u0026lt;dst\u0026gt; +：即使在不能fast-forward的情况下也要强制更新引用 src：源引用 dst：目的引用 可通过修改refspec的形式，自定义远程分支的位置、远程分支拉取到本地分支的位置、拉取哪些远程分支、推送哪些分支到远程分支；也可以通过git push/fetch origin \u0026lt;src\u0026gt;:\u0026lt;dst\u0026gt;的形式手动指定本次f/p操作 可将src留空以删除远程版本库的dst 选项 --set-upstream：fetch成功后将fetch的所有分支和本地对应分支设置为track关系，以供pull和push使用 实例 git fetch origin 获取远程仓库remote的所有分支，然后保存到本地 .git/refs/remotes/origin git fetch origin b 将远程仓库origin的b分支更新到本地远程分支b git pull git pull [-r | --rebase] [\u0026lt;repository\u0026gt;] [\u0026lt;refspec\u0026gt;...] 作用 拉取远程分支，然后和本地分支合并 原理 首先fetch到本地远程分支 然后将本地远程分支合并到本地分支 选项 -r：通过rebase方式合并，默认merge 实例 git pull origin main:master 将远程仓库origin的main分支下载到本地远程分支main，然后合并到本地master分支 git push git push [--all] [--prune] [-n | --dry-run] [-f | --force] [-d | --delete] [-u | --set-upstream] [-v | --verbose] [\u0026lt;repository\u0026gt;] [\u0026lt;refspec\u0026gt;...] 作用 使用本地引用更新远程引用，并且通过smart协议将远程缺失的提交上传 语义：将远程引用remote所指向的提交对象设置为local指向的提交对象 默认情况下远程仓库只会在可以进行fast-forward的时候才会设置成功 通过force选项可以强制覆盖，因此remote远程分支之前引用的提交对象会变dangle，因此可能在gc中移除 选项 --all：全部本地分支 --prune：删除没有本地对应分支的远程分支 -n：试运行 -d：删除列出的远程分支 -f：强制覆盖，即使不能fast-forward -u：push成功后，自动添加远程跟踪配置 repository：要推送到的远程仓库，可以是仓库URL，也可以是远程仓库的名称（remote命令所添加的），默认（branch.*.remote配置，再默认origin） 实例 git push 推送当前分支到配置的远程分支 git push origin master 推送本地master到origin的远程master git push origin :dev 删除远程dev git push origin +dev:master 把远程master重置为本地dev的提交 ","date":"2022-12-01T15:00:00+08:00","permalink":"https://brycerd.github.io/posts/git%E5%8E%9F%E7%90%86%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/","section":"posts","tags":["Git"],"title":"Git：原理、使用与实践"},{"categories":["技术"],"contents":"在计算机科学中，架构指软件系统的顶层结构，描述了系统内包含的子系统、模块、组件等个体，以及个体的分工、协作、运转机制。本文介绍了架构的概念、背景，详细阐述了架构设计的基本原则、设计流程和架构模式。\n概念 系统：由一群有关联的个体组成，根据某种规则运作，能完成单个元件不能单独完成的工作的群体。\n关联：系统内各个体存在关联关系 规则：系统内个体按照指定的规则分工、协作、运转 能力：系统产生并提供新能力 子系统：由若干个体组成的系统，同时是更大系统的一部分。\n模块：一套一致而互相有紧密关联的软件组织，通过接口表达模块提供的功能。\n组件：自包含的、可编程的、可重用的、与语言无关的软件单元。\n模块和组件都是系统的组成部分 模块侧重于从逻辑上划分系统 组件侧重于从物理上划分系统 框架：为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求的基础功能的软件产品。\n架构：软件系统的基础结构。\n架构 软件系统的顶层结构，描述了系统内包含的子系统、模块、组件等个体，以及个体的分工、协作、运转机制。\n背景 开发语言演进 机器语言(1940年之前) 直接用二进制码表示机器可以识别的指令和数据\n问题：难以编写、难以阅读、难以修改\n汇编语言(1940年代) 用助记符代替机器指令，用地址符号或标号代替地址\n优势：解决了机器语言读写复杂的问题\n问题：难以编写复杂逻辑、难以移植\n高级语言(1950年代) 参照数学语言设计、近似于人类日常语言的程序语言\n通过编译器将高级语言编译为适合不同ISA的机器语言\n优势：解决复杂逻辑开发问题和移植性问题\n问题：软件可维护性和可扩展性问题出现\n软件开发危机 第一次软件危机(1960-1970) 软件规模和复杂度增加，表现为软件质量低下、项目开发超支\n方案：软件工程、结构化程序设计\n结构化程序设计：抛弃goto语句，采取自顶向下、逐步细化、模块化的指导思想，将软件复杂度控制在一定范围内，本质上仍然是面向过程的设计思想\n第二次软件危机(1980年代) 软件难以扩展\n方案：面向对象程序设计\n面向对象程序设计：抽象、封装、继承、多态，增强软件的可扩展性\n软件架构(1990年代) 问题：软件规模庞大，内部耦合严重，开发效率低，维护和扩展困难，不能适应对性能、可用性、可扩展性的要求\n方案：软件架构设计\n软件架构设计：将系统划分为若干组件\n架构设计目的 架构设计的主要目的是：解决我们对软件系统的要求所带来的软件复杂度问题。\n复杂度来源：高性能 在大规模数据量、访问量的情况下，满足对系统响应时间、吞吐量、资源利用率的要求 复杂度来源：高可用 在软件、硬件、外部环境出现问题的情况下，满足对系统无中断执行、历史数据持久化、无丢失的要求 复杂度来源：可扩展 在新需求不断出现的情况下，满足对系统易于扩展能力的要求 复杂度来源：低成本、安全、规模 总结 随着计算机技术和人类社会的不断发展，我们对软件系统的要求不断升级，导致软件系统面对的复杂度不断升级，进而复杂度的解决方案不断升级。\n软件系统复杂度\n利用机器计算→读写机器代码困难→复杂逻辑开发困难、可移植性差→软件质量低下、难以维护→软件扩展性差→难以适应对高性能、高可用、可扩展的要求 解决方案\n机器语言→汇编语言→高级语言→软件工程、面向过程设计→面向对象设计→软件架构 演化方向\n向更高层、更高维度、更贴近问题而非机器的方向演进 设计原则 合适原则 宣言：合适优于业界领先\n合适：适于企业当前开发人力、技术积淀、业务规模，能合理的将资源整合并发挥出最大功效，并且快速落地\n简单原则 宣言：简单优于复杂\n简单：尽量避免结构的复杂性和逻辑的复杂性\n演化原则 宣言：演化优于一步到位\n演化：架构满足当前需要，在实际应用中不断迭代，业务变化时进行扩展、重构、甚至重写\n设计流程 识别复杂度 设计架构时，应首先将应用的主要复杂度来源列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题。\n系统是否需要高性能\n对系统QPS/TPS进行预估，一般情况下的计算公式 峰值QPS=均值QPS*3 目标QPS=峰值QPS*(2/4/8)，根据业务发展情况预估放大倍数，但一般不要超过10倍 系统是否需要高可用\n服务不可用对业务的影响 数据丢失对业务的影响 系统是否需要可扩展\n设计备选方案 针对高性能、高可用、可扩展等主要复杂度来源，存在若干经过时间和场景验证过的成熟技术，如高可用的主备方案、集群方案；高性能的负载均衡、多路复用方案，可扩展的分层、插件化方案。\n基于已有的技术或架构模式进行组合、调整，进而获取适合的架构设计方案，为了避免架构师认识局限、过度辩护、没有全面综合比较的问题，需要设计多个备选方案\n备选方案数量为3-5个\n备选方案的差异要比较明显\n备选方案的技术不要局限于已经熟悉的技术\n备选方案主要关注技术选型，而非技术细节，不可过于详细\n评估和选择备选方案 在评估备选方案时，应列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案。\n质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性。\n在选择备选方案时，应按优先级选择，即综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，再选择满足第二优先级的方案\u0026hellip;\n详细方案设计 确定方案后，进行详细方案设计，将方案涉及的关键技术细节确定下来。\n需要对技术选型的关键细节有较深入的理解\n通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度\n架构模式 高性能架构模式 高性能负载均衡 计算本身存在一个特点：同样的输入数据和逻辑，无论在哪台服务器执行，都应该得到相同的输出。由此，可以将系统分别部署到多台服务器，通过复杂均衡机制和策略，将用户请求分配到指定的服务器中进行处理，以此提升系统整体的计算能力。\n分类 DNS负载均衡\n原理 DNS服务器根据请求对同一域名返回不同区域/机房的IP地址，一般用来实现地理级别的负载均衡 优点 简单、成本低，无需自己开发或维护复杂均衡设备 就近访问、提升访问速度，DNS服务器可根据请求来源IP，将域名解析为离用户最近的服务器地址 缺点 更新不及时，由于DNS各级缓存，修改IP后很多用户不能及时获取新IP 扩展性差，DNS控制权在域名服务商中，无法进行定制化功能和扩展 分配策略简单，无法感知后端服务器状态 改进 部分公司采用HTTP-DNS方式替代LocalDNS服务，通过HTTP直接获取服务器IP，避免域名劫持、降低解析时延、进行精准调度、实时生效、扩展性强 硬件负载均衡\n原理 通过单独的硬件设备实现负载均衡，典型设备如F5和A10，一般用于实现集群级别的负载均衡 优点 功能强大，支持各层级复杂均衡、支持全面负载均衡算法 性能强大，可支持100万以上的并发 稳定性高，商用硬件，经过大规模测试和使用 支持安全防护，具备防火墙、防DDoS攻击等安全功能 缺点 价格昂贵 扩展性差，很难进行扩展和定制 软件负载均衡\n原理 通过负载均衡软件实现负载均衡，典型软件如Nginx(7层负载均衡，支持HTTP、Email协议)、LVS(4层负载均衡，即传输层的负载均衡)，一般用于实现机器级别的负载均衡 Nginx监听到请求后，根据负载均衡算法选择真实服务器RS，然后将请求转发给服务器，并接收返回值，然后将返回值发送给客户端 LVS通过NAT或DR方式进行负载均衡 NAT：收到客户端TCP包后，修改目的IP地址为RS地址，收到RS返回的TCP包后，修改源IP地址为LVS的IP地址 DR：首先，将LVS和RS都绑定到同一个VIP地址上；LVS收到客户端TCP包后，修改目的MAC地址为RS的MAC地址，然后RS处理后直接返回数据到客户端 优点 简单、便宜 灵活，可根据业务进行定制化操作 缺点 性能较低，一个Nginx可支持5万并发 不具备防火墙和防DDoS攻击等安全功能 算法 轮询 收到请求后，按照顺序轮流分配到服务器上\n不关注服务器本身的状态，只关注是否在运行\n加权轮询 收到请求后，根据服务器权重进行任务分配，一般是静态权重 负载最低优先 收到请求后，分配给当前负载最低的服务器\n负载可用TCP连接数、HTTP请求数、CPU负载、IO负载来衡量\n性能最优优先 收到请求后，分配给处理速度最快的服务器 Hash 根据请求中的某些关键信息进行Hash运算，将相同hash值的请求分配到同一台服务器中，以满足业务的需求\n如根据源IP地址Hash、根据ID Hash\n单服务器并发模型 单服务器高性能的关键之一是服务器采取的并发模型，即服务器如何管理连接、服务器如何处理请求，并最终取决于所采用的操作系统的进程模型(单进程、多进程、多线程)和IO模型(堵塞、非堵塞、同步、异步)\nPPC Process Per Connection，每次有新的连接就新建一个进程去专门处理这个连接的请求\n缺点\nfork代价高 父子进程通信复杂 支持的并发连接数量有限，CPU进程调度和切换代价高 TPC Thread Per Connection，每次有新的连接就新建一个线程去专门处理这个连接的请求\n缺点\n创建线程代价较创建进程低，但高并发时仍有性能问题，仍存在CPU线程调度和切换的代价问题 线程间的互斥和共享可能导致死锁问题 多线程之间可能会相互影响，某个线程出现异常时可能导致整个进行退出 IO多路复用 通过一个进程同时监听多个文件描述符，当所有文件都未就绪时，进程进入堵塞状态，否则开始处理已就绪的文件\n即避免了多进程监听IO时产生的创建、销毁和调度开销，也避免了单进程通过非堵塞IO读写数据时产生的空转和轮询开销\nReactor 基于IO多路复用实现高性能事件处理的模型，是事件驱动架构的一种模式\n核心模块\nReactor：监听和分配事件 资源池：进程池或者线程池，负责处理事件 单Reactor-单进程/线程\n架构 Reactor通过select监控连接对象，收到事件后通过dispatch进行分发 Acceptor处理连接建立事件，通过accept接受连接 Handler处理其他事件，通过read→业务处理→send进行业务流程的处理 优点 简单、无需进程间通信、无需解决同步互斥竞争等问题 缺点 无法返回多核多cpu的性能 在处理某个连接的业务时，无法处理其他连接，可能造成其他连接堵塞 单Reactor-多线程\n架构 Reactor通过select监控连接对象，收到事件后通过dispatch进行分发 Acceptor处理连接建立事件 Handler处理其他事件，通过read读取数据，然后通过Processor进行处理，并接收Processor的处理结果后通过send返回给client Processor在独立的子线程中完成真正的业务处理，并把处理结果返回给Handler 优点 充分利用多核多CPU的处理能力 缺点 多线程数据共享和访问比较复杂 主线程中Reactor承担所有事件的监听和响应，易成为性能瓶颈 多Reactor-多进程/线程\n架构 父进程中mainReactor通过select监控连接对象 父进程中Acceptor处理连接建立事件，并将建立的连接分配到子进程中 子进程中subReactor通过select监控父进程分配的连接对象 子进程中Handler处理其他事件，并进行业务处理和响应 优点 父子进程分工明确，父进程只负责监听和处理连接建立事件，子进程负责监听和处理其他事件 父子进程交互简单，父进程只需要把新连接传给子进程 Proactor 基于异步IO实现的事件驱动模型。\n架构\nProactor Initiator负责创建Proactor和Handler，并将其注册到内核 Async Operation Processor负责处理注册请求、完成IO操作，并通知Proactor Proactor根据不同的事件类型回调不同的Handler进行业务处理 优势\nProactor通过异步IO能够充分利用DMA特性，同时省去同步调用select、read等开销 缺点\nLinux下的AIO并不完善 高性能缓存架构 为了弥补数据库/存储系统在复杂运算重复计算和读多写少场景下的性能瓶颈，可通过缓存将可能重复使用的数据放在内存中，一次生成，多次使用，避免每次都访问存储系统。\n高性能缓存架构需要面临的一些问题\n缓存穿透\n概念：业务系统在缓存中没有查询到数据，导致需要到数据库中进行查找。 原因 存储数据不存在 解决方案 业务层对不合法请求进行过滤 推荐：可直接设置一个默认值存到缓存中 尽量不：通过布隆过滤器对不可能的数据进行过滤 缓存数据生成耗费大量时间或资源 爬虫系统访问大量缓存过期的数据，而数据生成需要耗费大量时间或资源 缓存击穿\n概念：缓存失效后对同一热点key的大量请求同时访问数据库进行更新缓存，造成存储系统崩溃 解决方案 更新锁 对缓存更新操作进行加锁保护，保证缓存失效时只有一个线程能够进行缓存更新 热点key可设置为永不过期 缓存雪崩\n概念：缓存中大量数据在同一时间点或较近时间段内全部失效，导致请求全部访问数据库 解决方案 缓存的过期时间随机波动 缓存有效期设置为永久，后台线程定时更新缓存 业务线程发现缓存不存在时可通过消息等方式通知后台线程进行更新 提高缓存系统容灾能力 提高数据库容灾能力 缓存热Key\n概念：特别热点的数据所在的服务器需要接受处理大量的访问请求，导致缓存服务器宕机，进而流量打到DB导致存储系统崩溃 解决方案 二级缓存，将热key数据缓存到服务器本地，优先从本地缓存获取 备份热Key，将热key数据复制存储到多台缓存服务器，访问时通过key+编号的方式访问 缓存更新策略\nCache Aside 查询：业务先从cache中获取数据，有数据则返回，否则业务方从数据库中同步取数据并更新到缓存中 更新：先将数据更新到数据库中，成功后让缓存失效 Cache Aside也不能完全避免数据库和缓存的不一致性，但相比其他方式：先更新缓存再更新数据库、先删除缓存再更新数据库、先更新数据库再更新缓存，不一致性的概率更小 可通过设置较短缓存有效期彻底消除不一致性问题，或通过分布式锁控制读取和更新的有序性。 Read/Write Through 查询：业务方直接到cache查询数据，不存在时cache组件从数据库中同步获取数据并更新到缓存中，此过程对业务方透明 更新：先查询要写入的数据在缓存中是否存在 如存在，则更新缓存中的数据，并由缓存组件同步更新到数据库中 如不存在 Write Allocate：写入缓存，再由缓存组件同步更新到数据库中 No-Write Allocate：不写入缓存，直接更新到数据库 Write Behind 更新：只更新到缓存，缓存采取定期或其他策略写入数据库 高性能NoSQL 为了弥补关系型数据库的以下缺点：\n存储行记录和基本类型，无法存储数据结构\n表结构schema强约束，难以扩展\n大数据计算场景下数据库IO很高\n全文搜索功能较弱，很难高效支持全字段索引和模糊搜索\n业界提出了许多不同的NoSQL方案：\nKV存储：解决关系型数据库无法存储数据结构的问题，如Redis\n文档数据库：解决关系型数据库强schema约束的问题，如MongoDB\n列式数据库：解决关系型数据库大数据计算场景下的IO问题，如HBASE\n全文搜索引擎：解决关系型数据库的全文搜索性能问题，如ElasticSearch\nKV存储 KV存储，即Key-Value存储，其中key是数据的标识，Value是具体的数据，KV存储的典型代表是Redis。\nRedis并不能支持完整的ACID事务，Redis提供的事务只能保证隔离性(一个Redis不会看到也不会影响到另一个Redis事务)，无法保证CAD\n文档数据库 文档数据库可以存储和读取任意结构的数据，no-schema存储，绝大部分文档数据库存储的数据格式是JSON。\n新增字段简单\n历史数据不会出错\n很容易存储复杂和异构数据\n不支持事务和Join\n列式数据库 列示数据库按列来存储数据\n业务同时读取多个列时效率高\n能够一次性完成对多个列的写操作\n一般用于海量数据进行离线存储和统计分析\n全文搜索引擎 全文搜索引擎支持\n全字段索引，任意组合\n模糊匹配，支持分词\n高性能数据库集群 关系型数据库以ACID特性+强大的SQL查询能力，目前仍然是各种业务系统中关键和核心的存储系统，在互联网时代，单台数据库服务器无法解决大数据高性能的要求，必须通过集群的方式分散压力，其中读写分离方式将访问压力分散到各个节点，但不分散存储压力、分库分表方式将访问压力和存储压力都分散到各个节点。\n读写分离 读写分离试讲数据库的读写操作分散到不同的节点上\n数据库服务器搭建主从集群，如一主一从、一主多从\n数据库主机负责读写操作，从机只负责读操作\n数据库主机通过复制机制将数据同步到从机，每台服务器都存储了所有的业务数据\n业务服务器将写操作发给数据库主机，将读操作发给数据库从机\n读写分离面临的核心复杂度是\n主从复制延迟\n主从复制延迟会导致一段时间内无法从从机读到主机写入的最新数据 解决方案 写操作后的读操作指定发送到主机 读从机失败后再读一次主机（安全问题+更新非新增无法重读问题） 关键核心业务读写操作全部发向主机，非关键业务用读写分离 分配机制\n即读写分离的位置 程序代码封装 在业务端/客户端抽象一个数据访问层，在该访问层中获取主从地址，并且负责将请求发送到主机或从机 中间件代理 独立出中间件系统，业务端直接访问中间件系统，中间价系统负责读写分离及管理数据库连接 分库分表 业务分库\n按照业务模块将数据分散到不同的数据库服务器 join问题 事务问题 成本问题 分表\n垂直分表 将表中某些不常用且占用大量空间的列拆分出去 表操作的数量要增加 水平分表 路由 范围路由 Hash路由 配置路由 join count order by 高可用架构模式 CAP定理 概念 在一个分布式系统(指互相连接并共享数据的节点的集合)中，当涉及读写操作时，只能保证一致性、可用性、分区容错性三者中的两个，另外一个必须被牺牲。\nConsistency，一致性\n对某个指定的客户端来说，读操作保证能返回最新的写操作结果\n即分布式系统中的线性一致性(原子一致性)\nAvailability，可用性\n非故障的节点在合理的时间内返回合理的响应(非错误和超时响应) Partition Tolerance，分区容错性\n当出现网络分区后，系统能够继续履行职责 要点 CAP中P是无法避免的。\nCAP关注的粒度是数据，而不是整个系统。\nCAP是忽略网络延时的，也即CAP假设某个节点写入的数据可以在瞬间复制到其他节点，而在实际系统中，瞬时复制无法实现，因此对于要求严格一致性的应用来说，对任一数据都只能通过单点写入的方式写入数据，无法实现多点写入，当然不同的数据可以分布到不同的单点上。\nCAP实际上是一种理论分析：在一个完全理想的网络环境中，CAP三者无法兼而得之。在实际的分布式系统中，即使是CP、AP、CA也都是无法保证的。\nBASE BASE是现实对CAP的折中\nBasically Available\n基本可用性，分布式系统在出现故障时，允许损失部分可用性，保证核心可用 Soft State\n软状态，允许系统存在中间状态 Eventually Consistency\n最终一致性，经过一定时间后，系统各节点达到一致的状态 ACID ACID是数据库理论中为了保证数据完整性所提出的一组属性。\nAtomicity\n原子性，即一个事务中的操作，要么全部完成，要么全部不完成，不会在中间某个环节结束 Consistency\n一致性，即在事务结束后，数据的完整性约束没有被破坏，即事务保证写入的数据依然满足数据库的规则约束，如非负数、触发器、外键等约束规则 Isolation\n隔离性，并发执行的不同事务间相互隔离，读写操作不会相互影响 Durability\n持久性，事务一旦提交，对数据的修改就是永久的，即使系统故障也不会丢失 高可用存储 存储高可用方案的本质都是将数据复制到多个存储设备，通过数据冗余的方式来实现高可用，因此核心问题是：如何应对复制延迟/中断导致的数据不一致问题。\n双机架构 常见的双机高可用存储架构包括：主备、主从、主备/主从切换、主主\n集群和分区 集群是多台机器组合在一起形成一个统一的系统。\n集群可分为数据集中集群，即一主多从、一主多备；数据分散集群，即数据分散到多个机器，形成多主多从、多主多备\n高可用计算 高可用计算通过增加更多服务器实现。\n异地多活 异地多活用来应对整个机房出现故障、突发情况的问题，异地指地理位置上不同的地方、多活指不同地理位置上的系统都能够提供业务服务\n同城异区\n跨城异地\n跨国异地\n核心思想：优先保证核心业务和优先保证绝大部分用户\n接口级故障 系统未宕机，网络未中断，但业务接口由于系统压力过大、负载太高导致无法快速处理业务请求，出现业务访问缓慢、大量访问异常、访问超时等问题。\n降级\n系统将某些业务或者接口的功能降低、只提供部分功能或者完全停掉功能。 熔断\n系统调用依赖的外部系统接口时，直接返回错误或不再调用 限流\n只允许系统能够承受的访问量，超出系统访问能力的请求丢弃 排队\n限流的变种，让用户等待一段时间 可扩展架构模式 面向流程拆分 将业务流程拆分为几个阶段，每个阶段作为一部分\n分层架构设计 保证各层的差异足够清晰，边界足够明显 分层的本质在于 隔离关注点：每个层都只关注和处理本层的逻辑 一旦分层确定，整个业务流程按照层依次处理，分层依赖限制为两两依赖 面向服务拆分 将系统提供的服务拆分，每个服务作为一部分\nSOA\nService Oriented Architecture，面向服务架构 所有业务功能都是一项服务 通过ESB(Enterprise Service Bus，企业服务总线)将不同的服务连接在一起 松耦合，各个服务独立运行，向后兼容 微服务架构\n系统按业务功能划分为一组微服务，每个微服务独立运行，微服务间通过HTTP等轻量级机制进行通信，微服务通过自动化系统进行部署、测试、监控、治理(服务注册、服务发现、服务路由、服务容错、服务安全) 核心是：服务粒度小、轻量级通信、自动化部署运维 面向功能拆分 向系统提供的功能拆分，每个功能作为一部分\n微内核架构\n面向功能进行拆分的可扩展架构，也称为插件化架构 核心系统：负责和具体业务功能无关的通用功能，例如模块加载、模块间通信 插件模块：负责实现具体的业务逻辑 关键技术 插件管理：插件注册表机制 插件连接：插件和核心系统的连接规范 插件通信 规则引擎\n开发人员将业务功能分解为多个规则 业务人员根据需要排列组合规则 规则引擎执行规则 ","date":"2022-10-01T10:00:00+08:00","permalink":"https://brycerd.github.io/posts/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","section":"posts","tags":["架构"],"title":"程序架构设计基础"},{"categories":["技术"],"contents":"写出可扩展、可读、可维护的高质量代码是对程序员的最高要求。本文介绍了软件开发中的经典设计原则和设计模式。\n前言 动机 应对面试中的设计模式相关问题\n写出高质量代码，提高程序员基础素养，打牢基本功\n提高复杂代码的设计和开发能力\n深入理解框架、开源项目、中间件的源码和精髓\n为职场发展做铺垫\n标准 可维护性\n在不破坏原有代码设计下，能够快速地修改或者添加代码，同时不会引入新的bug。 一般来说，代码的可读性好、简洁、可扩展性好，代码的可维护性就越高；细化来说，代码分层清晰、模块化好、高内聚低耦合、面向接口而非实现编程，代码的可维护性就越高 可读性\n代码易于阅读和理解。 代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合，影响着代码的可读性。 可扩展性\n在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。 可扩展性好的代码预留了一些功能扩展点，使得新功能代码可直接插入扩展点，而不用修改原有代码。 灵活性\n代码快速高效应对新变化的能力，即代码易扩展、易复用、易用的能力。 代码预留扩展点、代码抽象出底层可复用的模块/类、代码可应对各种使用场景/满足各种不同需求 简洁性\nKISS：Keep It Simple Stupid，保持代码简单、逻辑清晰。 可复用性\nDRY：Don\u0026rsquo;t Repeat Yourself，尽量减少重复代码的编写，复用已有的代码。 可测试性\n易于编写单元测试。 理论 设计思想 面向对象 封装、抽象、继承、多态 设计原则 SOLID原则：单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则\nDRY原则：Don\u0026rsquo;t Repeat Yourself\nKISS原则：Keep It Simple，Stupid\nYAGNI原则：You Ain\u0026rsquo;t Gonna Need It\nLOD原则：迪米特原则/最少知识原则\n设计模式 创建型：单例模式、工厂模式、建造者模式、原型模式\n结构型：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式\n行为型：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式\n编程规范 提高代码可读性 代码重构 重构的目的、对象、时机、方法\n重构不出错的技术手段：单元测试、代码的可测试性\n大重构、小重构\n设计原则与思想 面向对象 概念 面向对象编程：OOP，Object Oriented Programming，一种编程范式或风格，以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石。\n面向对象编程语言：支持类或对象的语法机制，能方便的实现面向对象的四大特性的编程语言。\nUML：Unified Model Language，统一建模语言\n特性 封装（数据访问保护、操作权限收敛）\n概念：信息隐藏或者数据访问保护，类通过暴露有限的访问接口，使外部仅能通过类提供的方式来访问内部信息或数据 实现：编程语言提供访问控制语法，如private、protected、public等 意义：操作权限收敛，提高代码的可读性和可维护性；对外暴露有限接口、隐藏内部属性，提高类的易用性 抽象（暴露接口、隐藏细节）\n概念：对外暴露操作接口、隐藏方法的具体实现 实现：如接口类、抽象类，广义上，函数也是抽象的实现 意义：使用者只需关注类提供的功能点，无需关注具体实现；提高代码的可扩展性和可维护性，修改实现不需要修改定义 继承（代码复用）\n概念：子类通过继承父类，获取父类的属性和方法 实现：编程语言提供继承语法，如extends 意义：代码复用；反映类之间的关系 多态（同一接口、不同行为）\n概念：同一个编程符号在运行时表现出不同行为的能力。 实现： 继承+方法重写 C++：编译器为含有虚函数的类生成一个虚函数表，同时该类生成的实例都会带有一个虚函数指针，子类进行方法重写后，虚函数表中对应的虚函数地址会覆写为子类重写后的函数地址；在运行时，调用虚函数时首先根据虚函数表指针定位到虚函数表，然后通过虚函数偏移定位到虚函数地址，从而实现动态绑定 Java：在运行时，根据符号引用到父类方法表中得到该方法在方法表中的偏移量（该偏移量仅在第一次解析时获取一次，然后将其存储/修改到字节码中），然后在当前实际调用该方法的实例中的方法表根据偏移量得到实际的地址，最后调用该地址，从而实现动态绑定 接口类 Java：运行时，根据符号引用到当前实例的方法表中根据方法名称搜索得到实际的地址 Go：运行时，将非空接口转为iface类型，将空接口转为eface类型，iface中包含接口类型、实例类型、接口实际方法表，接口实际方法表在运行时生成，首先编译时接口和实际类型的方法都按照方法名排序，然后运行时，实例强转为iface时，同时遍历实例的方法表和接口的方法表，如果二者名称相同，则将该实例方法地址加到iface接口实际方法表中，总时间复杂度为O(m+n) duck-typing 动态语言：在运行时调用方法，不存在则报错 Golang虽然不用显式声明实现了某接口，但实际上在编译时也会进行是否实现方法的检查，因此Golang严格意义上不是duck-typing 意义：提高代码的可扩展性和可复用性 对比：面向过程 概念 面向过程编程：以过程作为组织代码的基本单元，数据与方法分离，面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能 对比 OOP更加能够应对大规模复杂程序的开发\nOOP以类为思考对象，进行设计分析时，首先考虑如何对业务建模、如何将需求翻译为类、如何给类之间建立交互关系，之后再按照处理流程组装程序 OOP风格的代码更易复用、易扩展、易维护\nOOP通过封装、抽象、继承、多态等特性，使代码更易复用、易扩展、易维护 OOP更加贴近问题，更加远离底层机器\n误用 滥用getter、setter方法\n实际上抛弃了OOP提供的封装特性，数据操作权限分散 滥用全局变量和全局方法\n大而全的Constants常量类 将类拆解为功能更加单一的多个常量类 将业务类所需要的常量定义在类的内部 实际上不能复用的Utils类 优先定义到业务类 将类拆解为功能单一的多个Utils类 定义数据和方法分离的类\n基于贫血模型的开发模式：MVC架构 DTO、DO、PO只定义数据，不定义操作 操作定义在Controller、Service、Repository三层中 对于微小程序、数据处理相关程序、侧重算法而非数据的程序，面向过程的风格更为合适\n灵活采用OOP和OPP，本质是写出易维护、易读、易复用、易扩展的高质量代码\n抽象类vs接口 特性 抽象类\n不允许实例化，只能被继承 可以包含属性和方法，方法可以包含代码实现，也可以完全抽象 子类继承抽象类后，必须实现抽象类中的全部抽象方法 接口\n不能包含属性/成员变量 只能声明方法，不能包含实现 类实现接口时，必须实现接口声明的全部方法 意义 抽象类是对成员变量和方法的抽象，是一种is-a关系，解决代码复用问题，同时又强制子类实现抽象方法\n接口是对方法的抽象，是一种has-a关系，解决解耦问题，隔离接口和具体的实现，提高代码的可扩展性\n抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类\n接口是一种自上而下的设计思路，先设计接口并面向接口编程，然后再具体实现接口\n面向接口编程 含义：将接口和实现分离，封装不稳定的实现，暴露稳定的接口，上游系统面向接口而非实现编程，不依赖不稳定的实现细节，以此应对实现的变化，降低耦合性、提高扩展性\n抉择：如果某个功能只有一种实现方式，未来也不可能被其他实现方式替换，则就没必要设计接口，直接使用实现类即可\n组合vs继承 继承 表示is-a关系、支持多态特性、代码复用\n继承层次过深、继承关系复杂时\n代码可读性变差，需要同时追溯多个类 破坏类的封装特性，将父类的实现细节暴露给子类（protected） 子类和父类高度耦合，父类的修改直接影响全部子类 子类需要获取多个父类能力时，需要创造m*n个父类 组合 将父类提供的能力通过接口进行抽象，子类通过定义接口类型属性注入接口实现，并将方法委托给接口实现完成 组合+接口形成has-a关系，可替代is-a 接口可支持多态特性 组合+委托可实现代码复用 子类需要获取多个父类能力时，只需要创造m+n个类，然后进行组合 权衡 以代码复用为主要目的时，应考虑使用组合而非继承\n通过模板模式设计类时，应使用继承\n类之间的继承结构稳定、继承层次较浅、继承关系简单时，可采用继承\n否则，应使用组合\n贫血模型vs充血模型 概念 贫血模型：数据和逻辑分离，例如在MVC架构中，业务逻辑在Service层，每层的对象DTO/DO/PO仅是数据的载体，本身不带有业务逻辑方法\n充血模型：数据和数据对应的业务逻辑封装到同一个类中，例如在DDD的MVC架构中，Service层包含Service类和Domain类两部分，Domain类既包含数据，又包含业务逻辑\n领域驱动设计：指导如何解耦业务系统，划分业务模块，定义业务领域模型及交互\n权衡 贫血模型适合业务逻辑简单的系统开发，如仅是基于SQL的CRUD操作\n充血模型适合业务复杂的系统开发，如各种利息计算模型、还款模型等复杂业务的金融系统\n不同开发模式导致不同的开发流程\n贫血模型：SQL驱动，根据业务需求到DB中查找相应的表，然后定义PO/DO/DTO，并编写SQL获取填充 充血模型：领域驱动，事先梳理好所有的业务，定义领域模型所包含的属性和方法，领域模型相当于可复用的业务中间层 在充血模型的MVC开发中\nDomain类负责数据和业务逻辑 Service类负责与Repository交互，将PO转为Domain Service类负责跨领域模型的业务聚合功能 Service类负责一些非功能性与三方系统交互的工作，如幂等、事务、消息、提醒、日志、调用RPC接口 Controller层的DTO和Repository层的PO不涉及复杂的业务逻辑，没必要设计成充血模型 OOA\u0026amp;OOD OOA\n面向对象分析 需求分析清晰合理、不断迭代优化、做出合理取舍、权衡、假设 OOD\n面向对象设计 划分职责进而识别出有哪些类 定义类及属性和方法 定义类与类的交互关系：泛化、实现、组合、聚合、关联、依赖 将类组装起来并提供执行入口 设计原则 SRP 概念 SRP，Single Responsibility Principle，单一职责原则：一个类或者模块只负责完成一个职责(或者功能)\n不要设计大而全的类，要设计粒度小、功能单一的类，以实现代码高内聚低耦合，提高代码的复用性、可读性、可维护性\n判断 类中的代码行数、函数或者属性过多\n类依赖的其他类过多\n私有方法过多\n比较难给类起一个合适的名字\n类中大量的方法都是集中操作类中的某几个属性\n权衡 类拆分过细时，反而会降低内聚性，进而影响代码的可维护性 OCP 概念 OCP，Open Closed Principle，开闭原则：软件实体(模块、类、方法)应该对扩展开放、对修改关闭\n添加新功能时，应在已有代码的基础上扩展代码(新增模块、类、方法等)，而非修改已有代码\n不是完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发\n设计 扩展意识、抽象意识、封装意识\n识别出代码的可变部分和不可变部分 可变部分：需求迭代时变化的部分，事先留好扩展点 具体设计\n多态 依赖注入 基于接口而非实现编程 绝大部分的设计模式（如装饰器、策略、模板、职责链等） LSP 概念 LSP，Liskov Substitution Principle，里氏替换原则：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏\nLSP还可以描述为：Design By Contract，按照协议来设计，即子类在设计的时候，要遵守父类的行为约定/协议：父类定义了函数的行为约定(包括函数声明要实现的功能；对输入、输出、异常的约定；父类注释中罗列的任何特殊说明)，子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定\n使用 里氏替换原则用来指导继承关系中子类如何设计，核心是：Design By Contract，即子类不能违背父类的约束规则 ISP 概念 ISP，Interface Segregation Principle，接口隔离原则：客户端不应该被强迫依赖它不需要的接口 接口 一组API/RPC接口集合\n如果部分接口只被部分调用者使用，则需要把这部分接口隔离出来，单独给这部分调用者使用 单个API接口或函数\n如果部分调用者只需要函数中的部分功能，则需要把函数拆分成粒度更细的多个函数 OOP中的接口\n接口的设计尽量单一，不要让接口的实现类和调用者依赖不需要的接口函数 DIP 概念 DIP，Dependency Inversion Principle，依赖反转原则：高层模块不要依赖底层模块，高层模块和底层模块应该通过抽象来相互依赖，抽象不要依赖具体实现细节，具体实现细节依赖抽象。\nIOC，Inversion Of Control，控制反转：对程序执行流程的控制从程序员反转到框架\nDI，Dependency Injection，依赖注入：不通过new的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递/注入给类使用\nDI Framework，依赖注入框架：由框架自动创建对象、管理对象的生命周期、依赖注入等工作\nKISS \u0026amp; YAGNI 核心 KISS，Keep It Simple and Stupid：保持简单\n简单：逻辑复杂度、实现难度、代码可读性 原则 不要使用过于复杂、高级的技术实现代码 不要重复造轮子 不要过度优化、不要过度使用一些奇技淫巧 YAGNI，You Ain\u0026rsquo;t Gonna Need It：你不会需要它\n不要设计当前用不到的功能 不要编写当前用不到的代码 不要过度设计 DRY 核心 DRY，Don\u0026rsquo;t Repeat Yourself：不要重复\n实现逻辑重复，不一定违反DRY\n功能语义重复，违反DRY\n代码执行重复，违反DRY\n代码复用性 概念：代码可被复用的能力\n途径\n减少代码耦合 满足单一职责原则 模块化 业务与非业务逻辑分离 通用代码下沉 继承、多态、抽象、封装 应用模板等设计模式 Rule of Three\n如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，则可不考虑代码的复用性，在之后开发新的功能的时候，如果需要复用，再进行重构以支持复用 LOD 概念 高内聚、低耦合\n提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围 高内聚指导类本身的设计，低耦合指导类与类之间依赖关系的设计 高内聚\n概念：相近的功能应该放到同一类，不相近的功能不要放到同一个类 低耦合\n概念：代码中类与类之间的依赖关系简单清晰，即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类(依赖该类的类)的代码改动 LOD\nLaw Of Demeter：The Least Knowledge Principle：迪米特法则：最小知识原则 每个模块只应该了解那些和它关系密切的模块的有限知识，或者说，每个模块只和自己的朋友说话，不和陌生人说话。 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。 基于最小接口而非最大实现编程 案例实践 业务开发 追求长远发展的工程师，不能把自己只放在执行者的角色，不能只是一个代码实现者，还要有独立负责一个系统的能力，能端到端开发一个完整的系统：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护 案例：积分系统 需求分析\n借鉴竞品、借鉴其他平台/应用 线框图（UI图） 用户用例：侧重情景化，描述用户在一个特定的应用场景里的一个完整的业务操作流程 积分系统 积分赚取和兑换渠道：下订单、每日签到、评论 积分消费和兑换规则：抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分 积分及明细查询 系统设计\n合理的将功能划分到不同模块，实现模块层面的高内聚、低耦合，架构整洁清晰 一般来说，不希望下层系统包含太多上层系统的业务信息 如果一个功能的扩展、修改，需要涉及跨团队、跨项目、跨系统才能完成，则不符合低耦合的要求 积分系统 M1：积分赚取渠道、兑换规则、消费渠道、兑换规则的管理和维护由营销系统统一负责，积分系统仅负责积分的CRUD。订单系统等各业务系统-\u0026gt;营销系统-\u0026gt;积分系统 M2：积分赚取渠道、兑换规则、消费渠道、兑换规则的管理和维护由各业务系统各自负责和维护，积分系统仅负责积分的CRUD。订单系统等各业务系统-\u0026gt;计算实际积分-\u0026gt;积分系统 M：积分赚取渠道、兑换规则、消费渠道、兑换规则的管理和维护、积分的CRUD由积分系统统一负责。订单系统等各业务系统-\u0026gt;积分系统 设计模块与模块之间的交互关系 交互方式：同步接口调用、异步消息通知 设计模块的接口、数据库、业务模型 接口设计 数据库设计 业务模型设计 开发实现\n数据库设计 接口设计 接口粒度权衡 接口符合单一职责原则，粒度越小通用性越好 粒度过小时：一个功能要调用多个接口：性能问题、分布式数据一致性问题 兼顾易用性和性能：在职责单一的细粒度接口之上，封装一层粗粒度的接口给外部使用 业务模型设计 MVC分层意义\n分层能起到代码复用的作用 分层起到隔离变化的作用 分层起到隔离关注点的作用 分层能提高代码的可测试性 分层能应对系统的复杂性 DTO/DO/PO\n三者对应Controller、Service、Repository层的数据对象 每层都单独定义更好 可以抽象出一些通用结构解决复用性问题 可以提供一些工具类实现O之间的转化 DTO/PO可以定义为贫血模型，因为生存期较短，且不涉及复杂的业务逻辑 业务简单时，DO可以使用贫血模型，业务逻辑复杂时，最好使用充血模型 案例：接口调用统计框架 需求分析\n功能性需求 接口统计信息：接口响应时间的统计信息、接口调用次数的统计信息 统计信息的类型：max、min、avg、count、tps等 统计信息显示格式：json、html、自定义 统计信息显示终端：console、email、http、日志 统计触发方式：主动触发、被动触发 统计时间区间 统计时间间隔 非功能性需求 易用性 性能 扩展性 框架使用者可以较为方便的添加自定义插件 容错性 通用性 框架设计\nPrototype 聚焦一个简单的应用场景，设计实现一个简单的原型 模块划分 数据采集：打点采集原始数据，记录响应时间和请求时间；高度容错，不能影响接口本身的可用性；易于使用 存储：将采集的原始数据保存下来；减少对接口本身性能的影响，异步存储 聚合统计：将原始数据聚合为统计数据；可扩展、以便支持更多规则 显示：将统计数据以某种格式显示到终端 开发实现\n小步快跑、快速迭代 划分职责进而识别出有哪些类 编程规范与重构 概括 定义 重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低\n重构是在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量\n目的 重构是持续保证代码质量的有效手段\n随着业务的发展，系统的演进也是不可避免的\n重构是避免过度设计的有效手段\n对象 大型重构\n概念：对顶层代码设计的重构，包括系统、模块、代码结构、类与类之间的关系等的重构 手段：分层、模块化、解耦、抽象可复用组件 小型重构\n概念：对类、函数、变量等代码级别的重构 手段：规范命名、规范注释、消除超大类或函数、提取重复代码 时机 原则：可持续、可演进\n持续重构，把重构作为开发的一部分，作为开发规范的一部分，作为开发习惯的一部分\n时刻具有重构意识，避免开发初期过度设计、避免代码维护过程中质量下降\n单元测试 概念\n单元测试：对象是类或者函数，用来测试一个类或函数是否按照预期的逻辑执行 集成测试：对象是整个系统或功能模块 意义\n有效检查代码bug，提高代码质量 帮助发现代码设计问题 对集成测试的有力补充，覆盖各种边界情况 帮助快速熟悉代码 是TDD可落地执行的改进方案 避免：不经过单元测试和严格CR，通过 黑盒测试 发现问题再修改，测不出的问题在线上出问题时再修复\n可测试性 概念\n针对代码编写单元测试的难易程度 手段\n依赖注入是编写可测试代码的最有效手段，通过依赖注入，可通过mock的方式解决外部依赖 mock原因：外部对象参与逻辑执行、但又不受我们控制 anti-patterns\n未决行为 含有当前时间、随机数等逻辑的方法 将未决行为单独抽离 全局变量 静态方法 复杂继承 高耦合代码 解耦 概要 解耦，控制软件复杂度的方式，保证代码高内聚、低耦合，确保代码不至于复杂到难以维护的程度\n高内聚、低耦合\n功能聚焦在某一模块或类中，降低阅读和修改代码的难度 修改代码时改动集中，降低引入bug的风险 使代码可测试性更好 手段\n封装与抽象 隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口 中间层 引入中间层简化模块或类之间的依赖关系 模块化 单一职责原则 单一职责的类，依赖和被依赖的类会比较少，进而降低代码耦合度 面向接口而非实现编程 通过接口中间层隔离变化和具体的实现，在有依赖关系的两个模块或类之间，一方改动不会影响到另一方 本质：将强依赖关系解耦为弱依赖关系，易于插拔替换 依赖注入 将强依赖关系解耦为弱依赖关系，易于插拔替换 迪米特法则 编程规范 命名 核心：准确达意前提下，越短越好\n长度\n常见词可使用缩写，如sec-\u0026gt;second，num-\u0026gt;number 作用域小的变量，可以使用相对短的命名 作用域大的变量、模块、类，需要使用长的命名 利用上下文简化命名\n类属性不要重复类名 函数参数不必重复函数名称 命名必须可读可搜索\n避免使用生僻、难发音的英文单词 通用操作使用项目/团队内统一的命名，如查询统一用query，插入统一用insert 接口和抽象类\n接口可选统一加入前缀I，对应实现类加后缀Impl 抽象类可选统一加前缀Abstract 均可选，但需要项目内统一 注释 核心：使代码更易看懂\n注释应包括：做什么、为什么、怎么做，对一些边界情况、特殊情况进行说明，以及对函数输入、输出、异常进行说明\n注释适量，过少难以阅读代码，过多难以维护\n类和函数一定要写注释，而且要写的全面详细\n函数内部注释要相对少一些，通过好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性\n代码风格 类、函数的大小\n一个函数长度不要超过一屏 一行代码长度不要超过一屏 类的长度过长时：实现功能时无法确定使用哪个函数、想用的函数不容易找到、只用到一个小功能却要引入整个类 善用空行分割单元块\n编程技巧 把代码分割成更小的单元块\n避免函数参数过多\n拆分多个函数来减少参数 将函数的参数封装成对象 不用函数参数来控制逻辑\n不用布尔值或是否为null来控制逻辑 特例：对于private函数、且拆分后的两个函数经常同时被使用，则可保留参数 函数设计要职责单一\n移除过深的嵌套层次\n去掉多余的if、else 利用continue、break、return等关键字提前退出嵌套 调整执行顺序来减少嵌套 将部分嵌套逻辑封装成函数调用 使用解释性变量\n常量代替魔法数字 解释性变量来解释复杂表达式 案例实践 标准 通用标准\n目录设置是否合理、模块划分是否清晰、代码结构是否满足高内聚、低耦合 是否遵循经典的设计原则和设计思想 设计模式是否应用得当，是否有过度设计 代码是否易于扩展，如果添加新功能，是否容易实现 代码是否可以复用、是否重复造轮子 代码是否易于测试，单元测试是否全面覆盖了各种正常和异常的情况 代码是否易读，是否符合编码规范 业务标准\n代码是否实现了预期的业务需求 逻辑是否正确、是否处理了各种异常情况 日志打印是否得当、是否方便debug排查问题 接口是否易用、是否支持幂等、事务 代码是否存在并发问题、是否线程安全 性能是否有优化空间 是否有安全漏洞 程序出错返回 异常情况下，如何返回异常 返回错误码 直接返回错误码，或者将错误码设置到全局变量 返回NULL值 缺点：接收方需要做null值判断、影响代码正常逻辑和可读性 建议：对于get、query等查找不存在的记录，可以返回null或特殊值如-1 返回空对象 抛出异常对象 优点：携带更多异常信息；将正常逻辑和异常逻辑分离开来，提高代码可读性 建议：在Java中，对于代码bug和不可恢复的异常(如数据库连接失败)，使用Unchecked异常直接抛出；对于可恢复异常、业务异常，使用checked异常强制调用者捕获处理 重构 扩展性\n依赖接口，通过依赖注入的方式注入接口实现 通过继承复用流程操作 易用性\n提供封装了默认依赖的构造函数，内部自行初始化接口实现 默认依赖的配置信息可通过配置类读取 性能\n异步执行、线程或消息队列 计算可分治 容错性\n设计模式与范式 本质 设计模式的本质是解耦：以一种易维护、易读、易扩展、易用、易复用的方式实现代码之间的依赖。创建型模式将创建和使用代码解耦；结构型模式将不同功能代码解耦；行为型模式将不同行为代码解耦。 创建型 单例模式 概要 定义：一个类在程序的生命周期只允许创建一个实例\n作用：\n处理资源访问冲突、节省系统资源 表示全局唯一类：业务概念上只能存在一个实例的类 实现 构造函数通过private修饰，避免外部创建实例\n提供静态方法以提供单例对象\n考虑实例创建时的线程安全问题、考虑是否延迟加载、考虑getInstance性能是否高\n饿汉式\n在类加载时，创建并初始化实例 不支持延迟加载 懒汉式\n在实际调用getInstance方法时，才会创建并初始化实例 并发性能不高 double-check\n在getInstance方法中，首先检查实例是否创建，未创建时再加锁，加锁成功后再检查实例是否创建，未创建时才真正创建并保存到类中 支持延迟加载、并发性能提升 静态内部类\n单例类内部定义静态内部类，静态内部类内部在类初始化中创建单例类实例 利用Java特性：外部类加载时并不加载静态内部类，从而不会创建单例类实例，当getInstance真正访问静态内部类时，内部类才会被加载，此时才会创建单例类实例，同时类加载的线程安全性由JVM来保证 枚举\n利用Java枚举类本身的特性，无需提供getInstance方法，直接访问枚举对象来实现单例 问题 单例模式对OOP特性的支持不友好\n对OOP的抽象、继承、多态支持不友好 单例模式会隐藏类之间的依赖关系\n解决：将单例实例通过依赖注入的方式传递给实用类 单例模式对代码的扩展性不好\n单例模式对代码的可测试性不友好\n单例模式不支持有参数的构造函数\n解决 先执行init创建单例实例，再通过getInstance获取实例 将参数放到getInstance中，但会导致后续设置不起作用 将参数放到全局变量中 解决\n通过其他方式：工厂模式、IOC容器、程序自己保证等方式实现全局唯一类 权衡 单例类无后续扩展需求，不依赖外部系统，则可以设计成单例类，避免将单例实例在类之间传来传去 扩展 单例模式中唯一性的范围\n默认：进程内唯一 其他：线程内唯一：通过ThreadLocal或通过ConcurrentHashMap根据线程ID来实现 其他：集群内唯一：通过分布式锁+序列化文件来实现，保证任一时刻，集群内只有一个线程持有单例实例 多例模式\n一个类可以创建限定个数的实例 or 一个类对于指定的参数只能创建一个实例 通过ConcurrentHashMap实现 工厂模式 本质：类的构建和使用分离，使用者无需关心类的具体类型和构建过程\n隔离复杂性：类使用者既不用关心要创建哪个类，也不必关心如何创建该类，只需通过工厂模式获取即可 封装变化：类创建逻辑的变更对类的使用者透明 代码复用：类创建逻辑复用 控制复杂度：将创建代码抽离出来，使得类的职责更单一、代码更简洁 用途\n创建对象时需要通过复杂的if-else判断要创建哪个类 创建对象时需要组装多个其他类的对象或者需要复杂的初始化流程 简单工厂模式 概念：定义一个工厂类，提供一个静态方法，该方法根据参数的不同返回不同产品类的实例\n实现\n静态方法内部通过if-else判断要实例化哪个产品类 根据产品类特性 每次调用都产生一个新的产品类实例 预先为每个产品类产生一个实例，每次调用都返回之前已经创建的产品实例（单例） 对于对象创建逻辑较为简单的类，可通过简单工厂模式实现\n工厂方法模式 概念：定义一个用于创建对象的工厂接口，由实现此工厂接口的类来决定实例化哪个产品类\n实现\n通过配置文件+反射调用相应的工厂类 通过定义创建工厂的工厂类，此工厂类可通过map+工厂实现类单例的方式省去if-else判断 对于对象创建逻辑较为复杂的类，可通过工厂方法模式将每个产品类的创建逻辑拆分到不同的工厂类中\n抽象工厂模式 概念：定义一个创建一系列相关的对象（产品族）的工厂接口，由实现此工厂接口的类来决定实例化哪些类\n实现\n同工厂方法 工厂方法模式是在一类产品的不同实现上扩展；抽象工厂模式是在一组产品的相同实现上扩展\nDI容器 DI容器负责整个应用中所有类对象的创建 配置解析 通过读取配置文件，根据配置信息确定要创建哪些对象 对象创建 将所有类对象的创建放到一个工厂类BeansFactory中，根据反射的方式动态的加载类、创建对象 对象生命周期管理 配置对象是单例还是每次新创建、是否支持懒加载、对象的初始化和销毁方法 建造者模式 概要 定义：将一个复杂对象的构建和表示分离，从而使得同样的构建过程可以创建不同的表示\n本质：类的构建和表示(类本身的功能)分离，使用者可以方便的设置所需参数，无需关心复杂的构造过程\n实现\n传统：定义一个Builder接口，为每种复杂对象类定义一个Builder实现类，通过Director类调用Builder实现类进行构建，然后返回复杂对象 常用：定义一个Builder静态内部类，提供类的各字段的setter方法，提供build方法进行创建前的校验和实例的创建 场景\n复杂对象的构建 有大量必填参数，通过构造函数构建时可读性差 有大量可选参数，但部分可选参数存在相互依赖或者约束条件 希望对象构建后不可变，即setter方法私有 原型模式 概要 定义：通过复制原型实例的方式创建新对象\n实现\n浅拷贝：复制基本类型数据和引用对象的内存地址 深拷贝：复制基本类型数据和引用对象本身，以及递归深拷贝引用对象 序列化：序列化到文件或内存，然后再反序列化 推荐：不可变对象、或者对象和原型之间无需更改的对象可用浅拷贝，否则必须用深拷贝 场景\n对象创建成本很大，而对象和原型之间的大部分字段相同 对象中的数据需要复杂计算、或者从RPC、网络、数据库等慢速IO中读取 结构型 代理模式 概要 定义：为原始类提供代理类，通过代理类控制对原始类的访问\n实现\n静态代理 组合：代理类实现原始类的接口，通过依赖注入的方式注入原始类实例 继承：代理类继承原始类，重写public方法 动态代理 不事先为每个类编写代理类，在运行时动态创建代理类 场景\n业务系统的非业务功能性需求开发，如监控、统计、鉴权、限流 RPC框架作为远程代理 通过代理实现缓存 桥接模式 概要 定义\n原始：将抽象和实现解耦，让它们可以独立变化 抽象和实现 对应两种不同的独立变化的维度，二者通过组合的方式桥接在一起 通用：一个类存在两个或多个独立变化的维度，通过组合的方式，让这两个维度可以独立的进行扩展 实现\n一个维度通过抽象类实现，另一个维度通过接口类实现，二者通过组合的方式进行依赖，即接口类对象作为抽象类的一个属性 JDBC\n一般把JDBC视为桥接模式的经典实现，但是在JDBC中实际只有Driver一个变化维度，Driver作为DriverManger的一个属性，但是DriverManger本身没有变化 一种理解：可以将DriverManager视为JDBC规范的一个实现，即JDBC规范是另一个独立变化的维度 二种理解：JDBC是一种简化的桥接模式，实际上只有一种变化维度 装饰器模式 概要 定义：在不改变原有对象的基础上，动态地给一个对象添加增强功能\n本质：利用组合替代继承，给原始类添加增强功能\n实现\n装饰器类和原始类继承相同的抽象类或实现相同的接口；原始类通过依赖注入的方式注入到装饰器类中 场景\n扩展一个类的功能 动态的、连续的给一个对象添加功能，对象具有的功能等到运行时才真正确定 区别\n装饰器模式和代理模式 二者的实现方式类似，但思想不同 装饰器模式侧重为所装饰的类提供增强功能，而且可以叠加嵌套 代理模式侧重对所代理的对象施加访问控制，并不提供对象本身的增强功能，一般用在端点，不再叠加 适配器模式 概要 定义：将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而导致无法一起工作的两个类可以一起工作\n实现\n类适配器 适配器类继承原始类，实现目标接口，在接口方法中调用父类相应方法 对象适配器 适配器类通过组合方式注入原始类实例，实现目标接口，在接口方法中调用原始类实例的相应方法 权衡 原始类接口不多时，都可 原始类接口很多，且原始类和目标接口大部分接口都相同，则通过类适配器实现 原始类接口很多，且原始类和目标接口大部分不同，则通过对象适配器实现 场景\n本质：适配器模式是一种补偿模式，用来弥补设计上的缺陷 封装有缺陷的接口设计 依赖的外部类在接口设计上有缺陷，如大量静态方法，则可自定义更好的接口，然后定义适配器类封装外部类 统一多个类的接口设计 依赖多个(相同功能)外部类实现某一功能，但外部类/接口的定义不同，则可自定义统一的接口，然后定义适配器类封装外部类，然后内部类就可只依赖自定义接口，隔离外部类的变化 替换依赖的外部系统 替换依赖的外部接口时，可定义适配器类实现原外部接口，同时使用新外部类实现功能 兼容老版本接口 不直接删除待废弃的接口，而是将其内部逻辑委托给新的接口实现 适配不同格式的数据 门面模式 概要 定义：为子系统提供一组统一的接口，定义一组高层接口让子系统更易用\n实现：在提供细粒度接口的同时，根据实际需要增加高层接口组装底层接口\n场景\n解决易用性问题 封装系统的底层实现，隐藏系统的复杂性，提供一组更简单易用、更高层的接口 解决性能问题 将多个接口替换为一个门面接口调用，减少网络通信成本 门面接口不多时，可直接将门面接口和非门面接口放到一组；否则，可再抽象出一层接口 解决分布式事务问题 把不可分的操作放到一个门面接口实现 组合模式 概要 定义：将一组对象组织成树形结构，以表示一种部分-整体的层次结构，让客户端可以统一对单个对象和组合对象的处理逻辑\n实现：叶子结点对象和中间节点对象都继承/实现同一个抽象类，中间节点对象在具体实现时注入抽象类对象列表，以此实现树的构建；通过递归的方式建树并实现功能\n场景\n数据可以表示成树这种数据结构，业务需求可通过在树上的递归算法来实现 享元模式 概要 定义：共享细粒度不可变对象，实现对象复用\n本质：缓存共享对象，降低内存消耗和重复构建造成的性能损失\n实现：将原始类中存在大量重复的字段封装成享元类，通过工厂模式在工厂类中通过Map或List缓存已经创建好的享元类对象，原始类通过享元工厂获取并共享享元对象\n场景：大量对象存在重复字段、重复字段改动很小\n区别\n享元的目的是实现共享复用节约内存，池化技术侧重重复使用节约时间 单例保证对象全局唯一，享元则保证属性相同的对象共享使用 行为型 观察者模式 概要 定义：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知\n本质：将状态变化和状态响应分离\n实现\n被观察者提供注册方法注入观察者对象；观察者对象实现观察接口进行自定义操作；被观察者状态发生变化时遍历观察者对象并调用处理方法 被观察者调用观察者的方式 同步阻塞 观察者在同一个线程内依次遍历并调用被观察者 异步非阻塞 启动新的线程遍历并调用被观察者 被观察者启动新线程执行自定义操作 通过EventBus实现 通过消息队列组件通知跨进程的观察者 框架 EventBus，提供实现观察者模式的骨架代码\n定义Observer，Observer可以是任意Object EventBus通过register注册Observer、通过unregister删除Observer EventBus通过post向匹配的Observer发送event Observer通过Subscribe注解标明事件处理函数 实现\nSubscribe 注解类，用于标明观察者的哪个函数用来接受消息 ObserverAction 标明Subscribe注解修饰的方法，主要用在ObserverRegistry观察者注册表中 ObserverRegistry 实现register方法，将Observer添加到观察者注册表 EventBus 暴露接口 框架：隐藏实现细节、降低开发难度、做到代码复用、解耦业务与非业务代码，让程序员聚焦业务开发\n模板模式 概要 定义：在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。\n实现：\n经典：父类定义一个final方法作为模板方法，内部调用abstract方法，子类重写abstract方法实现扩展 作用\n复用 复用父类的模板逻辑 扩展 在不改变框架源码的情况下，定制化框架的功能 场景\n框架开发，用于提供功能扩展点，让框架用户在不修改源码的情况下，基于扩展点定制化框架功能 回调 A类将回调函数注册到B类方法中，从而在A类调用B类方法时，B类方法又反过来调用A注册的回调函数\n回调和模板模式类似，回调函数类似模板模式中的abstract方法，回调函数注册到的函数即为模板函数\n回调方式\n同步回调：在函数返回之前执行回调函数 异步回调：在函数返回之后执行回调函数 对比：模板vs回调\n场景类似：在某一方法的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的 实现不同：模板基于继承，回调基于组合 模板模式中子类不可再继承 模板模式中针对每种不同的实现都要定义子类 模板模式中如果定义多个模板方法，则子类必须实现全部抽象方法 模板模式中能利用父类提供的属性等能力，而回调中无法利用主函数 策略模式 概要 定义：定义一组算法类，将每个算法分别封装起来，让它们可以相互替换\n本质：策略模式解耦策略的定义、创建、使用\n实现\n定义策略 定义一个策略接口和一组实现这个接口的策略类 创建策略 定义一个策略工厂，根据策略类型创建并返回策略实例 根据策略是否有状态 提前创建策略实例放到map中获取单一实例 通过if-else判断，每次创建新实例 使用策略 运行时动态确定使用哪种策略 运行时直接获取到策略类型 运行时根据参数if-else判断策略类型 策略提供判断方法accept，只有accept返回true时才进行处理 场景：根据需求不断扩展策略\n职责链模式 概要 定义：将请求的发送和接受解耦，让多个接收对象都有机会处理这个请求，将这些接收对象串成一条链，并沿着链传递该请求，直到链上的某个接收对象能够处理它为止。\n实现\n链表实现 定义抽象父类Handler，类中包含抽象处理方法handle，同时包含后继接收对象Handler字段 定义多个子类继承Handler，在handle中处理请求，如果能处理该请求，则不再传递给后继对象，否则，传递给后继对象继续处理 定义职责链类，类提供add添加Handler，并通过Handler的后继组成链表，然后提供handle方法从职责链头结点开始处理 数组实现 定义接口Handler 定义职责链类，内部包含Handler列表，处理时从头遍历，如果已处理则break 变体\n原始定义中，当某一接受对象能够处理请求时不再向后传递请求 变体：请求会被所有的处理器处理一遍 场景\n敏感词过滤 拦截器 框架提供职责链类，从而使得用户在不改变框架源码的前提下可以增加处理器自定义拦截、过滤逻辑 作用\n拆分处理器类，满足单一职责原则，降低复杂性 满足开闭原则，提高代码扩展性 状态模式 概要 定义：实现状态机时，将事件触发的状态转移和动作执行，拆分到不同的状态类中，避免分支判断逻辑 状态机 有限状态机：有限个状态以及在这些状态之间的转移和动作等行为的模型\n状态 事件 动作 事件触发状态转移及动作的执行 实现方式\n分支逻辑法 在每个事件/处理函数中，根据状态机的流转图和当前所处的状态，更新状态、触发动作 对于复杂状态机，易漏写错写状态转移，也难以维护修改 查表法 以当前状态和事件作为表的两个维度，分别以目标状态和触发行为作为表的内容，构建两个转移表 在每个事件处理函数中，只需查表得到目标状态和触发动作即可 易于维护，易于扩展；但触发动作复杂时有一定局限性 状态模式 将事件触发的状态转移和动作执行，拆分到不同的状态类中，避免分支判断逻辑 实现 定义一个状态接口，接口中包含全部事件 定义一个状态机类，维护一个当前状态，当事件发生时，调用当前状态的事件方法即可 每种状态定义一个状态类，实现状态接口，状态类注入状态机，同时重写自己支持的事件接口方法，在该方法中实现状态机的状态转移，然后完成相应的动作 优化：将状态类作为单例类，将状态机类作为参数放置在事件方法 权衡 分支逻辑法：适合状态少、事件少、动作简单 查表法：适合状态多、事件多、转移复杂 状态模式：适合状态少、事件少、触发动作复杂 迭代器模式 概要 定义：提供一种按顺序访问集合、容器对象元素的方法，同时又无需暴露集合内部表示\n实现\n定义迭代器类，通过依赖注入方式传递容器类实例，定义hasNext、next、currentItem方法进行遍历 作用\n将复杂迭代逻辑拆分到迭代器类中，隔离复杂度 每个迭代器独享游标信息，支持多个迭代器同时进行遍历 基于迭代器接口，易于扩展新的迭代方式，更符合开闭原则 问题\n在通过迭代器遍历集合时，增加、删除集合元素会导致不可预期的遍历结果 方案：增删元素后，让迭代器遍历报错 扩展\n支持快照功能的迭代器：为容器创建迭代器的时候，相当于为容器创建快照，之后即使在原容器增删元素，也不会影响迭代器的遍历和容器快照的数据 方案 在迭代器类中定义一个成员变量snapshot存储快照，创建时拷贝原容器数据到快照容器中 实现简单；代价高、增加内存消耗 在容器中为每个元素增加两个时间戳：创建时间戳和删除时间戳；迭代器类中增加创建迭代器时的当前时间戳，迭代时只访问创建时间戳小于当前时间戳且删除时间戳为0或大于当前时间戳的元素 问题：无法实现容器的随机访问 解决：定义两个数组，一个数组真正删除，另一个数组不删除 访问者模式 概要 定义：允许一个或者多个操作作用到一组对象上，解耦操作和对象本身\n实现\n一组数据子类继承自同一接口或父类 一组业务操作子类继承自访问者接口或父类Vistor，接口Vistor通过重载包含对全部对象的操作 数据子类提供accept方法，方法接受访问者类作为参数，然后将实例自身作为参数调用访问者类方法 访问者类中通过重载实现不同对象的不同操作 场景\n针对一组类型不同但继承同一父类、接口的对象，在不同的业务场景下，需要对这组对象进行一系列不相关的业务操作，但为了避免不断添加功能导致类不断膨胀、职责越来越多、修改越来越频繁、分散，访问者模式将对象和操作解耦，将业务操作抽离出来，分别定义在独立细分的访问者类中 对比\n可以将一组相同操作分别针对不同的目标类型定义到独立的类，然后通过工厂模式返回相应的操作类 目标类型多、操作多时需要定义大量的类 Dispatch Single Dispatch\n执行哪个对象的方法，在运行时根据对象的运行时类型确定 执行该对象的哪个方法，在编译时根据方法参数的编译时类型确定 Double Dispatch\n执行哪个对象的方法，在运行时根据对象的运行时类型确定 执行该对象的哪个方法，在运行时根据方法参数的运行时类型确定 备忘录模式 概要 定义：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。\n实现\n定义快照类Snapshot，用于保存主类对象的历史数据，同时只暴露get方法保证不变形 定义快照管理类，用于保存全部快照数据，同时提供pop、push接口 主类提供创建快照方法：返回快照；提供恢复快照方法：接受快照实例 优化\n快照中只存储增量不存储全量 场景\n防丢失、撤销、恢复 命令模式 概要 定义：将命令封装为一个对象，这样可以将不同的命令依赖注入到其他对象，并且能够支持请求的排队执行、记录日志、撤销等功能\n实现\n定义命令接口 不同的命令定义不同的命令类实现命令接口 根据客户端输入的命令操作调用不同的命令类实例 场景\n控制命令的执行，如异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志 作用\n请求的调用者和接收者解耦，二者通过命令对象交互 解释器模式 概要 定义：为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法\n实现\n将语法解析的工作拆分到各个小类中 将语法规则拆分成一些小而独立的单元，对每个单元进行解析，最终合并为整个语法规则的解析 中介模式 概要 定义：定义一个单独的中介对象，用来封装一组对象之间的交互，将这组对象之间的交互委派给中介对象交互，避免对象之间的直接交互\n作用：实现参与者之间的解耦，简化交互关系\n场景\n参与者之间的交互关系复杂，既可以时消息发送者，也可以是消息接收者 原则 避免过度设计 设计的初衷是提高代码质量\n设计的过程是先有问题后有方案\n设计的应用场景是复杂代码\n持续重构能有效避免过度设计\n避免设计不足 一定的理论知识储备\n一定的刻意训练\n一定要有代码质量意识、设计意识\n开源与项目实战 开源实战 Java JDK Calender Calendar类提供大量跟日期相关的功能代码，同时又提供了一个getInstance工厂方法，用来根据不同的TimeZone和Locale创建不同的Calendar子类对象\nCalendar类同时通过内部静态Builder类实现建造者模式\n工厂模式：创建不同但相关类型的对象；建造者模式：创建一种类型但构建复杂、通过设置可选参数创建同一类型但不同的对象\nCollections Collections类是一个集合容器的工具类，提供很多静态方法用来创建各种集合容器\nCollections通过静态方法创建的UnmodifiedCollection类、CheckedCollection、SynchronizedCollection类都是针对Collection类的装饰器类\n新版本JDK中，Enumeration作为适配器类，适配客户端类和Iterator类\nCollections.sort方法通过模板模式，将比较大小这部分逻辑委托给用户实现\n实际上通过回调机制实现 也可以看做非典型策略模式 Runtime 每个JVM进程只对应一个Runtime实例，用来查看JVM状态以及控制JVM行为\n饿汉式实现\n","date":"2022-10-01T08:00:00+08:00","permalink":"https://brycerd.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"posts","tags":["设计模式"],"title":"设计模式"}]